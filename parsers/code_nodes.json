[
  {
    "id": 197,
    "name": "OrderRequest",
    "type": "class",
    "current_summary": "Class in orchestrator",
    "snippet": "class OrderRequest(BaseModel):\n    symbol: str = Field(..., example=\"AAPL\")\n    quantity: int = Field(..., example=100)\n    order_type: OrderType = Field(..., example=\"BUY\")",
    "filePath": "..\\trade-platform\\orchestrator\\src\\app.py",
    "serviceName": "orchestrator",
    "new_summary": "Request model for placing trade orders. Defines required fields: symbol (stock ticker), quantity (number of shares), and order_type (BUY/SELL). Used by orchestrator to validate incoming order requests."
  },
  {
    "id": 198,
    "name": "OrderResponse",
    "type": "class",
    "current_summary": "Class in orchestrator",
    "snippet": "class OrderResponse(BaseModel):\n    order_id: str\n    status: str\n    message: str\n    trace_id: str\n    latency_ms: Optional[int] = None\n    details: Optional[Dict[str, Any]] = None",
    "filePath": "..\\trade-platform\\orchestrator\\src\\app.py",
    "serviceName": "orchestrator",
    "new_summary": "Response model for order placement operations. Returns order status (EXECUTED/REJECTED/FAILED), unique order_id, trace_id for debugging, optional latency metrics, and detailed execution information including pricing, risk assessment, and performance breakdown."
  },
  {
    "id": 196,
    "name": "OrderType",
    "type": "class",
    "current_summary": "Class in orchestrator",
    "snippet": "class OrderType(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"",
    "filePath": "..\\trade-platform\\orchestrator\\src\\app.py",
    "serviceName": "orchestrator",
    "new_summary": "Enum defining valid order types in the trading system: BUY (purchase shares) or SELL (liquidate shares). Used across all services to ensure consistent order type handling."
  },
  {
    "id": 199,
    "name": "call_service",
    "type": "function",
    "current_summary": "Execute HTTP request to downstream microservice with error handling.",
    "snippet": "def call_service(url: str, method: str, trace_id: str, json_data: dict = None, timeout: float = 5.0):\n    \"\"\"\n    Execute HTTP request to downstream microservice with error handling.\n    \n    Args:\n        url: Full URL of the service endpoint\n        method: HTTP method ('POST' or 'GET')\n        trace_id: Trace ID to propagate in request headers\n        json_data: Optional JSON payload for POST requests\n        timeout: Request timeout in seconds (default: 5.0)\n    \n    Returns:\n        dict: JSON response from the service\n    \n    Raises:\n        HTTPException: On timeout, HTTP errors, or service failures with appropriate status codes\n    \n    Note:\n        Automatically adds 'X-Trace-Id' header for distributed tracing\n    \"\"\"\n    headers = {\"X-Trace-Id\": trace_id}\n    try:\n        if method == \"POST\":\n            response = requests.post(url, json=json_data, headers=headers, timeout=timeout)\n        elif method == \"GET\":\n            response = requests.get(url, headers=headers, timeout=timeout)\n        else:\n            raise ValueError(f\"Unsupported method: {method}\")\n        \n        response.raise_for_status()\n        return response.json()\n    except requests.Timeout as e:\n        logger.error(f\"[call_service] Timeout calling {url}\", extra={'trace_id': trace_id, 'function': 'call_service'})\n        raise HTTPException(status_code=504, detail=f\"Service timeout: {url}\")\n    except requests.HTTPError as e:\n        # Extract detailed error message from service response\n        try:\n            error_detail = e.response.json().get('detail', f\"Service error: {url}\")\n        except:\n            error_detail = f\"Service error: {url}\"\n        logger.error(f\"[call_service] HTTP error calling {url} - status {e.response.status_code}: {error_detail}\", \n                    extra={'trace_id': trace_id, 'function': 'call_service', 'extra_data': {'status_code': e.response.status_code, 'error_detail': error_detail}})\n        raise HTTPException(status_code=e.response.status_code, detail=error_detail)\n    except Exception as e:\n        logger.exception(f\"[call_service] Error calling {url} - {str(e)}\", extra={'trace_id': trace_id, 'function': 'call_service', 'extra_data': {'url': url, 'error_type': type(e).__name__}})\n        raise HTTPException(status_code=500, detail=f\"Service call failed: {url}\")",
    "filePath": "..\\trade-platform\\orchestrator\\src\\app.py",
    "serviceName": "orchestrator",
    "new_summary": "Helper function to make HTTP requests to downstream microservices. Handles POST/GET methods, adds distributed tracing headers, implements timeout handling (default 5s), and converts service errors into appropriate HTTP exceptions with detailed error messages."
  },
  {
    "id": 201,
    "name": "get_order_status",
    "type": "function",
    "current_summary": "Get the status of a specific order",
    "snippet": "def get_order_status(order_id: str, request: Request):\n    \"\"\"Get the status of a specific order\"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    logger.info(\"[get_order_status] Fetching order status\", extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'get_order_status'})\n    \n    try:\n        # Query all services for order information\n        trade_info = call_service(f\"{TRADE_SERVICE_URL}/trades/{order_id}\", \"GET\", trace_id)\n        \n        return {\n            \"order_id\": order_id,\n            \"trace_id\": trace_id,\n            \"trade_info\": trade_info\n        }\n    except HTTPException as e:\n        if e.status_code == 404:\n            raise HTTPException(status_code=404, detail=\"Order not found\")\n        raise",
    "filePath": "..\\trade-platform\\orchestrator\\src\\app.py",
    "serviceName": "orchestrator",
    "new_summary": "Retrieves current status and details of a specific order by querying the trade service. Returns order information including trade execution details. Raises 404 error if order not found."
  },
  {
    "id": 200,
    "name": "place_order",
    "type": "function",
    "current_summary": "Place a new order - orchestrates the entire trade flow",
    "snippet": "def place_order(order: OrderRequest, request: Request):\n    \"\"\"\n    Place a new order - orchestrates the entire trade flow\n    \n    Example payload:\n    {\n        \"symbol\": \"AAPL\",\n        \"quantity\": 50,\n        \"order_type\": \"BUY\"\n    }\n    \"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    order_id = str(uuid.uuid4())\n    \n    # Start overall timing\n    overall_start = time_module.time()\n    \n    # Create trace-specific log file\n    get_trace_logger(trace_id)\n    \n    logger.info(f\"[place_order] Order placement initiated\", extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order'})\n    logger.info(f\"[place_order] Order Details - Symbol: {order.symbol}, Quantity: {order.quantity}, Type: {order.order_type}\", \n                extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'symbol': order.symbol, 'quantity': order.quantity, 'order_type': order.order_type.value}})\n    \n    # Store partial results for detailed error reporting\n    trade_result = None\n    pricing_result = None\n    risk_result = None\n    \n    try:\n        # Step 1: Validate trade with Trade Service\n        logger.info(\"[place_order] STEP 1: Starting trade validation with Trade Service\", extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order'})\n        trade_data = {\n            \"order_id\": order_id,\n            \"symbol\": order.symbol,\n            \"quantity\": order.quantity,\n            \"order_type\": order.order_type.value\n        }\n        logger.info(f\"[place_order] Sending validation request to {TRADE_SERVICE_URL}/trades/validate\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': trade_data})\n        \n        validation_start = time_module.time()\n        trade_result = call_service(\n            f\"{TRADE_SERVICE_URL}/trades/validate\",\n            \"POST\",\n            trace_id,\n            trade_data\n        )\n        validation_duration_ms = int((time_module.time() - validation_start) * 1000)\n        \n        logger.info(f\"[place_order] validate_trade completed in {validation_duration_ms}ms\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'duration_ms': validation_duration_ms, 'service': 'trade_service'}})\n        logger.info(f\"[place_order] validate_trade response - Valid: {trade_result.get('valid')}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': trade_result})\n        \n        if not trade_result.get(\"valid\"):\n            logger.warning(f\"[place_order] VALIDATION FAILED - Reason: {trade_result.get('reason')}\", \n                         extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'reason': trade_result.get('reason')}})\n            return OrderResponse(\n                order_id=order_id,\n                status=\"REJECTED\",\n                message=trade_result.get(\"reason\", \"Trade validation failed\"),\n                trace_id=trace_id,\n                details=trade_result\n            )\n        \n        # Use normalized quantity from validation\n        actual_quantity = trade_result.get(\"normalized_quantity\", order.quantity)\n        if actual_quantity != order.quantity:\n            logger.info(f\"[place_order] Using normalized quantity: {actual_quantity} (original: {order.quantity})\", \n                       extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'original': order.quantity, 'normalized': actual_quantity}})\n        \n        # Step 2: Get pricing and PnL from Pricing-PnL Service\n        logger.info(\"[place_order] STEP 2: Starting pricing and PnL calculation with Pricing-PnL Service\", extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order'})\n        pricing_data = {\n            \"order_id\": order_id,\n            \"symbol\": order.symbol,\n            \"quantity\": actual_quantity,\n            \"order_type\": order.order_type.value\n        }\n        logger.info(f\"[place_order] Sending pricing request to {PRICING_PNL_SERVICE_URL}/pricing/calculate\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': pricing_data})\n        \n        pricing_start = time_module.time()\n        pricing_result = call_service(\n            f\"{PRICING_PNL_SERVICE_URL}/pricing/calculate\",\n            \"POST\",\n            trace_id,\n            pricing_data\n        )\n        pricing_duration_ms = int((time_module.time() - pricing_start) * 1000)\n        \n        logger.info(f\"[place_order] calculate_pricing completed in {pricing_duration_ms}ms\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'duration_ms': pricing_duration_ms, 'service': 'pricing_service'}})\n        logger.info(f\"[place_order] calculate_pnl response - Price: ${pricing_result.get('price')}, Total Cost: ${pricing_result.get('total_cost')}, Est. PnL: ${pricing_result.get('estimated_pnl')}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': pricing_result})\n        \n        # Step 3: Assess risk with Risk Service\n        logger.info(\"[place_order] STEP 3: Starting risk assessment with Risk Service\", extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order'})\n        risk_data = {\n            \"order_id\": order_id,\n            \"symbol\": order.symbol,\n            \"quantity\": actual_quantity,\n            \"price\": pricing_result.get(\"price\"),\n            \"pnl\": pricing_result.get(\"estimated_pnl\"),\n            \"order_type\": order.order_type.value\n        }\n        logger.info(f\"[place_order] Sending risk assessment request to {RISK_SERVICE_URL}/risk/assess\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': risk_data})\n        \n        risk_start = time_module.time()\n        try:\n            risk_result = call_service(\n                f\"{RISK_SERVICE_URL}/risk/assess\",\n                \"POST\",\n                trace_id,\n                risk_data,\n                timeout=15.0\n            )\n            risk_duration_ms = int((time_module.time() - risk_start) * 1000)\n            \n            logger.info(f\"[place_order] assess_risk completed in {risk_duration_ms}ms\", \n                       extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'duration_ms': risk_duration_ms, 'service': 'risk_service'}})\n        except HTTPException as timeout_ex:\n            risk_duration_ms = int((time_module.time() - risk_start) * 1000)\n            if timeout_ex.status_code == 504:\n                logger.error(f\"[place_order] Risk service timeout - request exceeded limit after {risk_duration_ms}ms\", \n                            extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'service': 'risk_service', 'duration_ms': risk_duration_ms}})\n                return OrderResponse(\n                    order_id=order_id,\n                    status=\"FAILED\",\n                    message=\"Risk assessment service timeout\",\n                    trace_id=trace_id,\n                    details={\n                        \"validation\": trade_result,\n                        \"pricing\": pricing_result,\n                        \"risk\": {\n                            \"error\": \"timeout\",\n                            \"message\": \"Risk service did not respond within timeout period (5 seconds)\",\n                            \"attempted_at\": datetime.now().isoformat()\n                        }\n                    }\n                )\n            raise\n        \n        logger.info(f\"[place_order] Risk Service response - Level: {risk_result.get('risk_level')}, Score: {risk_result.get('risk_score')}, Approved: {risk_result.get('approved')}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': risk_result})\n        logger.info(f\"[place_order] Risk Recommendation: {risk_result.get('recommendation')}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order'})\n        \n        # Check if risk is acceptable\n        if risk_result.get(\"risk_level\") == \"HIGH\" and risk_result.get(\"approved\") is False:\n            logger.warning(\"[place_order] ORDER REJECTED - High risk assessment failed approval\", \n                         extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'risk_level': 'HIGH', 'risk_score': risk_result.get('risk_score')}})\n            return OrderResponse(\n                order_id=order_id,\n                status=\"REJECTED\",\n                message=\"Order rejected due to high risk\",\n                trace_id=trace_id,\n                details={\n                    \"trade\": trade_result,\n                    \"pricing\": pricing_result,\n                    \"risk\": risk_result\n                }\n            )\n        \n        # Step 4: Execute the trade\n        logger.info(\"[place_order] STEP 4: Proceeding with trade execution at Trade Service\", extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order'})\n        execution_data = {\n            \"order_id\": order_id,\n            \"symbol\": order.symbol,\n            \"quantity\": actual_quantity,\n            \"price\": pricing_result.get(\"price\"),\n            \"order_type\": order.order_type.value\n        }\n        logger.info(f\"[place_order] Sending execution request to {TRADE_SERVICE_URL}/trades/execute\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': execution_data})\n        \n        execution_start = time_module.time()\n        execution_result = call_service(\n            f\"{TRADE_SERVICE_URL}/trades/execute\",\n            \"POST\",\n            trace_id,\n            execution_data\n        )\n        execution_duration_ms = int((time_module.time() - execution_start) * 1000)\n        \n        logger.info(f\"[place_order] execute_trade completed in {execution_duration_ms}ms\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'duration_ms': execution_duration_ms, 'service': 'trade_service'}})\n        logger.info(f\"[place_order] Trade execution completed - Status: {execution_result.get('status')}, Time: {execution_result.get('execution_time')}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': execution_result})\n        logger.info(\"[place_order] Order executed successfully\", extra={\n            'trace_id': trace_id,\n            'order_id': order_id,\n            'function': 'place_order',\n            'extra_data': {\n                'final_status': 'EXECUTED',\n                'symbol': order.symbol,\n                'quantity': actual_quantity,\n                'price': pricing_result.get('price'),\n                'total_cost': pricing_result.get('total_cost'),\n                'estimated_pnl': pricing_result.get('estimated_pnl'),\n                'risk_level': risk_result.get('risk_level'),\n                'risk_score': risk_result.get('risk_score')\n            }\n        })\n        \n        # return OrderResponse(\n        #     order_id=order_id,\n        #     status=\"EXECUTED\",\n        #     message=f\"Order executed successfully: {order.order_type} {actual_quantity} {order.symbol} @ ${pricing_result.get('price')}\",\n        #     trace_id=trace_id,\n        #     details={\n        #         \"execution_flow\": {\n        #             \"validation\": {\n        #                 \"status\": \"passed\",\n        #                 \"normalized_quantity\": actual_quantity,\n        #                 \"duration_ms\": validation_duration_ms,\n        #                 \"timestamp\": trade_result.get('timestamp')\n        #             },\n        #             \"pricing_calculation\": {\n        #                 \"price_per_share\": pricing_result.get('price'),\n        #                 \"total_cost\": pricing_result.get('total_cost'),\n        #                 \"estimated_pnl\": pricing_result.get('estimated_pnl'),\n        #                 \"duration_ms\": pricing_duration_ms,\n        #                 \"timestamp\": pricing_result.get('timestamp')\n        #             },\n        #             \"risk_assessment\": {\n        #                 \"risk_level\": risk_result.get('risk_level'),\n        #                 \"risk_score\": risk_result.get('risk_score'),\n        #                 \"approved\": risk_result.get('approved'),\n        #                 \"risk_factors\": risk_result.get('risk_factors'),\n        #                 \"duration_ms\": risk_duration_ms,\n        #                 \"timestamp\": risk_result.get('timestamp')\n        #             },\n        #             \"execution\": {\n        #                 \"status\": execution_result.get('status'),\n        #                 \"duration_ms\": execution_duration_ms,\n        #                 \"execution_time\": execution_result.get('execution_time')\n        #             }\n        #         },\n        # })\n        \n        # Calculate overall end-to-end latency\n        overall_duration_ms = int((time_module.time() - overall_start) * 1000)\n        \n        logger.info(f\"[place_order] Order completed successfully in {overall_duration_ms}ms (end-to-end)\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', \n                          'extra_data': {'total_duration_ms': overall_duration_ms, 'status': 'EXECUTED'}})\n        \n        return OrderResponse(\n            order_id=order_id,\n            status=\"EXECUTED\",\n            message=f\"Order executed successfully: {order.order_type} {actual_quantity} {order.symbol} @ ${pricing_result.get('price')}\",\n            trace_id=trace_id,\n            latency_ms=overall_duration_ms,\n            details={\n                \"performance\": {\n                    \"total_duration_ms\": overall_duration_ms,\n                    \"breakdown\": {\n                        \"validation_ms\": validation_duration_ms,\n                        \"pricing_ms\": pricing_duration_ms,\n                        \"risk_assessment_ms\": risk_duration_ms,\n                        \"execution_ms\": execution_duration_ms\n                    }\n                },\n                \"execution_flow\": {\n                    \"validation\": {\n                        \"status\": \"passed\",\n                        \"normalized_quantity\": actual_quantity,\n                        \"duration_ms\": validation_duration_ms,\n                        \"timestamp\": trade_result.get('timestamp')\n                    },\n                    \"pricing_calculation\": {\n                        \"price_per_share\": pricing_result.get('price'),\n                        \"total_cost\": pricing_result.get('total_cost'),\n                        \"estimated_pnl\": pricing_result.get('estimated_pnl'),\n                        \"duration_ms\": pricing_duration_ms,\n                        \"timestamp\": pricing_result.get('timestamp')\n                    },\n                    \"risk_assessment\": {\n                        \"risk_level\": risk_result.get('risk_level'),\n                        \"risk_score\": risk_result.get('risk_score'),\n                        \"approved\": risk_result.get('approved'),\n                        \"risk_factors\": risk_result.get('risk_factors'),\n                        \"duration_ms\": risk_duration_ms,\n                        \"timestamp\": risk_result.get('timestamp')\n                    },\n                    \"execution\": {\n                        \"status\": execution_result.get('status'),\n                        \"duration_ms\": execution_duration_ms,\n                        \"execution_time\": execution_result.get('execution_time')\n                    }\n                },\n                \"summary\": {\n                    \"symbol\": order.symbol,\n                    \"order_type\": order.order_type.value,\n                    \"quantity\": actual_quantity,\n                    \"price\": pricing_result.get('price'),\n                    \"total_cost\": pricing_result.get('total_cost'),\n                    \"estimated_pnl\": pricing_result.get('estimated_pnl'),\n                    \"risk_level\": risk_result.get('risk_level'),\n                    \"performance\": {\n                        \"overall_duration_ms\": overall_duration_ms,\n                        \"validation_ms\": validation_duration_ms,\n                        \"pricing_ms\": pricing_duration_ms,\n                        \"risk_assessment_ms\": risk_duration_ms,\n                        \"execution_ms\": execution_duration_ms\n                    }\n                }\n            }\n        )\n        \n    except HTTPException as e:\n        logger.error(f\"[place_order] Order placement failed - {str(e.detail)}\", extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order'})\n        \n        # Determine failure stage\n        if not trade_result:\n            failure_stage = \"validation\"\n        elif not pricing_result:\n            failure_stage = \"pricing_calculation\"\n        elif not risk_result:\n            failure_stage = \"risk_assessment\"\n        else:\n            failure_stage = \"execution\"\n        \n        # Build execution flow showing where it failed\n        execution_flow = {}\n        \n        if trade_result:\n            execution_flow[\"validation\"] = {\n                \"status\": \"passed\",\n                \"normalized_quantity\": trade_result.get('normalized_quantity'),\n                \"duration_ms\": validation_duration_ms if 'validation_duration_ms' in locals() else None,\n                \"timestamp\": trade_result.get('timestamp')\n            }\n        \n        if pricing_result:\n            execution_flow[\"pricing_calculation\"] = {\n                \"price_per_share\": pricing_result.get('price'),\n                \"total_cost\": pricing_result.get('total_cost'),\n                \"estimated_pnl\": pricing_result.get('estimated_pnl'),\n                \"duration_ms\": pricing_duration_ms if 'pricing_duration_ms' in locals() else None,\n                \"timestamp\": pricing_result.get('timestamp')\n            }\n        \n        if risk_result:\n            execution_flow[\"risk_assessment\"] = {\n                \"risk_level\": risk_result.get('risk_level'),\n                \"risk_score\": risk_result.get('risk_score'),\n                \"approved\": risk_result.get('approved'),\n                \"timestamp\": risk_result.get('timestamp')\n            }\n        \n        # Add failure information\n        execution_flow[\"failure\"] = {\n            \"stage\": failure_stage,\n            \"message\": str(e.detail),\n            \"status_code\": e.status_code\n        }\n        \n        # Calculate overall duration even for failures\n        overall_duration_ms = int((time_module.time() - overall_start) * 1000)\n        \n        logger.error(f\"[place_order] Order failed after {overall_duration_ms}ms - {str(e.detail)}\", \n                    extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', \n                           'extra_data': {'total_duration_ms': overall_duration_ms, 'status': 'FAILED', 'failure_stage': failure_stage}})\n        \n        return OrderResponse(\n            order_id=order_id,\n            status=\"FAILED\",\n            message=f\"Order failed at {failure_stage.replace('_', ' ')}: {str(e.detail)}\",\n            trace_id=trace_id,\n            latency_ms=overall_duration_ms,\n            details={\n                \"performance\": {\n                    \"total_duration_ms\": overall_duration_ms,\n                    \"failure_at_stage\": failure_stage\n                },\n                \"execution_flow\": execution_flow\n            }\n        )\n    except Exception as e:\n        logger.exception(f\"[place_order] Order placement failed - {str(e)}\", extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'place_order', 'extra_data': {'error_type': type(e).__name__}})\n        raise HTTPException(status_code=500, detail=f\"Order placement failed: {str(e)}\")",
    "filePath": "..\\trade-platform\\orchestrator\\src\\app.py",
    "serviceName": "orchestrator",
    "new_summary": "Orchestrates the complete trade workflow across all microservices. Steps: (1) Validates trade with Trade Service, (2) Calculates pricing/PnL with Pricing Service, (3) Assesses risk with Risk Service, (4) Executes trade if approved. Tracks end-to-end latency, handles failures at each stage, and returns detailed execution summary with performance metrics."
  },
  {
    "id": 202,
    "name": "OrderType",
    "type": "class",
    "current_summary": "Class in pricing_pnl_service",
    "snippet": "class OrderType(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Enum defining valid order types in pricing service: BUY or SELL. Used to determine cost calculation logic (BUY adds fees, SELL deducts fees from proceeds)."
  },
  {
    "id": 203,
    "name": "PricingRequest",
    "type": "class",
    "current_summary": "Class in pricing_pnl_service",
    "snippet": "class PricingRequest(BaseModel):\n    order_id: str\n    symbol: str = Field(..., example=\"AAPL\")\n    quantity: int = Field(...)\n    order_type: OrderType",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Request model for pricing calculations. Contains order_id for tracking, symbol (stock ticker), quantity (shares to trade), and order_type. Used by orchestrator to request price and PnL estimates."
  },
  {
    "id": 204,
    "name": "PricingResponse",
    "type": "class",
    "current_summary": "Class in pricing_pnl_service",
    "snippet": "class PricingResponse(BaseModel):\n    order_id: str\n    symbol: str\n    price: float\n    estimated_pnl: float\n    total_cost: float\n    timestamp: str",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Response model for pricing calculations. Returns calculated price per share, estimated profit/loss (PnL), total cost including fees/commissions, and timestamp. Used by orchestrator to determine order feasibility."
  },
  {
    "id": 211,
    "name": "adjust_price_for_slippage",
    "type": "function",
    "current_summary": "Apply slippage adjustment to execution price.",
    "snippet": "def adjust_price_for_slippage(price: float, slippage: float, order_type: OrderType) -> float:\n    \"\"\"\n    Apply slippage adjustment to execution price.\n    \n    Args:\n        price: Original market price\n        slippage: Slippage percentage as decimal (e.g., 0.015 for 1.5%)\n        order_type: BUY or SELL\n    \n    Returns:\n        float: Adjusted price rounded to 2 decimal places\n    \n    Price Adjustment:\n        - BUY: price increases (unfavorable for buyer)\n        - SELL: price decreases (unfavorable for seller)\n    \n    Note:\n        Slippage always works against the trader to simulate real market conditions\n    \"\"\"\n    if order_type == OrderType.BUY:\n        # Buying: price goes up (unfavorable)\n        adjusted_price = price * (1 + slippage)\n    else:  # SELL\n        # Selling: price goes down (unfavorable)\n        adjusted_price = price * (1 - slippage)\n    \n    return round(adjusted_price, 2)",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Applies market slippage to execution price based on order type. For BUY orders, increases price (unfavorable to buyer). For SELL orders, decreases price (unfavorable to seller). Simulates real market conditions where orders don't execute at exact quoted price."
  },
  {
    "id": 209,
    "name": "calculate_commission",
    "type": "function",
    "current_summary": "Calculate trading commission with volume-based discount tiers.",
    "snippet": "def calculate_commission(quantity: int, price: float, order_type: OrderType, trace_id: str, order_id: str) -> float:\n    \"\"\"\n    Calculate trading commission with volume-based discount tiers.\n    \n    Args:\n        quantity: Number of shares\n        price: Price per share\n        order_type: BUY or SELL (currently unused)\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        float: Commission amount rounded to 2 decimal places\n    \n    Commission Tiers:\n        - Order value > $100,000: 0.2% commission\n        - Order value > $50,000: 0.3% commission\n        - Order value â‰¤ $50,000: 0.5% commission (base rate)\n    \n    Note:\n        Early rounding may cause precision loss on large orders\n    \"\"\"\n    logger.info(\"[calculate_commission] Calculating commission\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_commission'})\n    \n    base_commission = 0.005  # 0.5% base rate\n    order_value = quantity * price\n    \n    logger.info(f\"[calculate_commission] Order value: ${order_value:.2f}\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_commission',\n                      'extra_data': {'order_value': order_value, 'quantity': quantity, 'price': price}})\n    \n    # Volume-based discount tiers\n    if order_value > 100000:\n        commission_rate = 0.002  # 0.2% for large orders\n        logger.info(\"[calculate_commission] Applied large order discount (0.2%)\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_commission'})\n    elif order_value > 50000:\n        commission_rate = 0.003  # 0.3% for medium orders\n        logger.info(\"[calculate_commission] Applied medium order discount (0.3%)\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_commission'})\n    else:\n        commission_rate = base_commission\n    \n    commission = order_value * commission_rate\n    \n    # Round commission to 2 decimal places for standard currency representation\n    commission_rounded = round(commission, 2)\n    \n    logger.info(f\"[calculate_commission] Commission calculated: ${commission_rounded:.2f} ({commission_rate*100}% of ${order_value:.2f})\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_commission', \n                      'extra_data': {'commission_before_rounding': commission, 'commission_final': commission_rounded, 'rate': commission_rate}})\n    \n    return commission_rounded",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Calculates trading commission using tiered pricing model. High-value orders (>$100K) get 0.2% rate, medium orders (>$50K) get 0.3%, and standard orders get 0.5% base rate. Returns commission amount rounded to 2 decimals."
  },
  {
    "id": 208,
    "name": "calculate_estimated_pnl",
    "type": "function",
    "current_summary": "Calculate estimated profit/loss for the order.",
    "snippet": "def calculate_estimated_pnl(symbol: str, quantity: int, price: float, order_type: OrderType, trace_id: str, order_id: str) -> float:\n    \"\"\"\n    Calculate estimated profit/loss for the order.\n    \n    Args:\n        symbol: Stock ticker symbol\n        quantity: Number of shares\n        price: Current market price per share\n        order_type: BUY or SELL\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        float: Estimated P&L rounded to 2 decimal places\n            - Positive: Profit (selling above cost basis)\n            - Negative: Loss (buying above cost basis or selling below)\n    \n    Calculation:\n        BUY: PnL = -(price - cost_basis) * quantity (negative = paying premium)\n        SELL: PnL = (price - cost_basis) * quantity (positive = profit)\n    \"\"\"\n    logger.info(f\"[calculate_estimated_pnl] Calculating PnL for {order_type} order\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_estimated_pnl'})\n    \n    cost_basis = get_cost_basis(symbol)\n    price_diff = price - cost_basis\n    \n    if order_type == OrderType.BUY:\n        pnl = -(price_diff * quantity)  # Negative because we're buying\n        logger.info(f\"[calculate_estimated_pnl] BUY PnL: ${pnl:.2f} (paying ${price} vs cost basis ${cost_basis})\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_estimated_pnl',\n                          'extra_data': {'pnl': pnl, 'price': price, 'cost_basis': cost_basis}})\n    else:  # SELL\n        pnl = price_diff * quantity  # Positive because we're selling\n        logger.info(f\"[calculate_estimated_pnl] SELL PnL: ${pnl:.2f} (selling at ${price} vs cost basis ${cost_basis})\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_estimated_pnl',\n                          'extra_data': {'pnl': pnl, 'price': price, 'cost_basis': cost_basis}})\n    \n    return round(pnl, 2)",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Estimates profit or loss for the order by comparing current price to cost basis. For BUY orders, returns negative PnL (cost premium). For SELL orders, returns positive PnL if selling above cost basis. Critical for risk assessment."
  },
  {
    "id": 212,
    "name": "calculate_pnl",
    "type": "function",
    "current_summary": "Calculate estimated profit/loss (simplified version for backward compatibility)",
    "snippet": "def calculate_pnl(symbol: str, quantity: int, current_price: float, order_type: OrderType) -> float:\n    \"\"\"\n    Calculate estimated profit/loss (simplified version for backward compatibility)\n    \"\"\"\n    cost_basis = get_cost_basis(symbol)\n    \n    if order_type == OrderType.BUY:\n        pnl = -(current_price - cost_basis) * quantity\n    else:  # SELL\n        pnl = (current_price - cost_basis) * quantity\n    \n    return round(pnl, 2)",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Simplified PnL calculation function for backward compatibility. Compares current price to cost basis to estimate profit/loss. Returns negative value for BUY orders (paying premium) and positive value for SELL orders (realizing gains)."
  },
  {
    "id": 213,
    "name": "calculate_pricing",
    "type": "function",
    "current_summary": "Calculate pricing and estimated PnL for an order",
    "snippet": "def calculate_pricing(request_data: PricingRequest, request: Request):\n    \"\"\"\n    Calculate pricing and estimated PnL for an order\n    This combines pricing lookup and PnL estimation\n    \"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    # Create trace-specific log file\n    get_trace_logger(trace_id)\n    \n    logger.info(\"[calculate_pnl] Pricing calculation request received\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_pnl'})\n    logger.info(f\"[calculate_pnl] Calculating pricing - Symbol: {request_data.symbol}, Quantity: {request_data.quantity}, Type: {request_data.order_type}\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": request_data.order_id,\n        \"function\": \"calculate_pnl\",\n        \"symbol\": request_data.symbol,\n        \"quantity\": request_data.quantity\n    })\n    \n    try:\n        # Get market price\n        logger.info(f\"[calculate_pnl] get_market_price for symbol: {request_data.symbol}\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'get_market_price'})\n        current_price = get_market_price(request_data.symbol)\n        \n        logger.info(f\"[get_market_price] Market price retrieved: ${current_price}\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": request_data.order_id,\n            \"function\": \"get_market_price\",\n            \"symbol\": request_data.symbol,\n            \"price\": current_price\n        })\n    except ValueError as e:\n        logger.error(f\"[get_market_price] Market data unavailable for symbol: {request_data.symbol}\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": request_data.order_id,\n            \"function\": \"get_market_price\",\n            \"symbol\": request_data.symbol,\n            \"error\": str(e)\n        })\n        raise HTTPException(status_code=404, detail=f\"Unable to retrieve market price for symbol '{request_data.symbol}'. Symbol not found in market data feed.\")\n    \n    try:\n        order_value = current_price * request_data.quantity\n        \n        logger.info(f\"[calculate_pnl] Calculating total order value: {request_data.quantity} x ${current_price} = ${order_value}\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_pnl', 'extra_data': {'order_value': order_value}})\n        \n        # Apply bulk order pricing adjustment\n        if request_data.quantity > 500:\n            adjusted_multiplier = 0.98\n            order_value = order_value * adjusted_multiplier\n            \n            logger.info(f\"[calculate_pnl] Applied bulk pricing adjustment: final value ${order_value:.2f}\", extra={\n                'trace_id': trace_id,\n                'order_id': request_data.order_id,\n                'function': 'calculate_pnl',\n                'extra_data': {'adjusted_value': order_value}\n            })\n        \n        logger.info(f\"[calculate_pnl] Order value ${order_value:.2f} calculated successfully\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_pnl', 'extra_data': {'order_value': order_value}})\n        \n        # Calculate total cost based on order type\n        logger.info(\"[calculate_pricing] Step 2: Calculating total cost and PnL\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_pricing'})\n        \n        cost_breakdown = calculate_total_cost(request_data.quantity, current_price, request_data.symbol, request_data.order_type, trace_id, request_data.order_id)\n        estimated_pnl = calculate_estimated_pnl(request_data.symbol, request_data.quantity, current_price, request_data.order_type, trace_id, request_data.order_id)\n        \n        total_cost = cost_breakdown['total_cost']\n        \n        timestamp = datetime.now().isoformat()\n        \n        # Store pricing data\n        pricing_data[request_data.order_id] = {\n            \"order_id\": request_data.order_id,\n            \"symbol\": request_data.symbol,\n            \"price\": current_price,\n            \"quantity\": request_data.quantity,\n            \"estimated_pnl\": estimated_pnl,\n            \"total_cost\": total_cost,\n            \"timestamp\": timestamp\n        }\n        \n        logger.info(\"[calculate_pnl] Pricing calculation completed\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": request_data.order_id,\n            \"function\": \"calculate_pnl\",\n            'extra_data': {\n                'symbol': request_data.symbol,\n                'price': current_price,\n                'quantity': request_data.quantity,\n                'estimated_pnl': estimated_pnl,\n                'total_cost': total_cost\n            }\n        })\n        \n        return PricingResponse(\n            order_id=request_data.order_id,\n            symbol=request_data.symbol,\n            price=current_price,\n            estimated_pnl=estimated_pnl,\n            total_cost=total_cost,\n            timestamp=timestamp\n        )\n        \n    except HTTPException:\n        # Re-raise HTTPException without logging as unexpected error\n        raise\n    except Exception as e:\n        logger.exception(\"[calculate_pnl] Unexpected error in pricing calculation\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": request_data.order_id,\n            \"function\": \"calculate_pnl\",\n            \"extra_data\": {\"error\": str(e), \"error_type\": type(e).__name__}\n        })\n        raise HTTPException(status_code=500, detail=f\"Pricing calculation failed: {str(e)}\")",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Main pricing calculation endpoint. Retrieves current market price, applies bulk discounts (>500 shares), calculates total cost including commissions/fees, estimates PnL, and stores pricing data for order tracking. Handles symbol not found errors with 404 response."
  },
  {
    "id": 207,
    "name": "calculate_total_cost",
    "type": "function",
    "current_summary": "Calculate comprehensive cost breakdown including all fees and commissions.",
    "snippet": "def calculate_total_cost(quantity: int, price: float, symbol: str, order_type: OrderType, trace_id: str, order_id: str) -> Dict[str, float]:\n    \"\"\"\n    Calculate comprehensive cost breakdown including all fees and commissions.\n    \n    Args:\n        quantity: Number of shares to trade\n        price: Price per share\n        symbol: Stock ticker symbol\n        order_type: BUY or SELL\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        dict: Cost breakdown with keys:\n            - 'base_amount': Base cost (BUY) or gross proceeds (SELL)\n            - 'commission': Trading commission\n            - 'fees': Exchange/regulatory fees\n            - 'total_cost': Final amount (including all fees)\n    \n    Note:\n        BUY orders: total_cost = base + commission + fees (amount to debit)\n        SELL orders: total_cost = base - commission - fees (net proceeds)\n    \"\"\"\n    logger.info(f\"[calculate_total_cost] Calculating cost for {order_type} order\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_total_cost'})\n    \n    if order_type == OrderType.BUY:\n        base_cost = quantity * price\n        commission = base_cost * 0.005  # 0.5%\n        exchange_fee = quantity * 0.01  # $0.01 per share\n        total_cost = base_cost + commission + exchange_fee\n        \n        logger.info(f\"[calculate_total_cost] BUY cost breakdown - Base: ${base_cost:.2f}, Commission: ${commission:.2f}, Fees: ${exchange_fee:.2f}, Total: ${total_cost:.2f}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_total_cost',\n                          'extra_data': {'base_cost': base_cost, 'commission': commission, 'exchange_fee': exchange_fee, 'total': total_cost}})\n        \n        return {'base_amount': base_cost, 'commission': commission, 'fees': exchange_fee, 'total_cost': total_cost}\n    else:  # SELL\n        gross_proceeds = quantity * price\n        commission = gross_proceeds * 0.005  # 0.5%\n        sec_fee = gross_proceeds * 0.0000207  # SEC fee\n        \n        # For large SELL orders of certain stocks, extra fee applied\n        if quantity > 200 and symbol in [\"TSLA\", \"NVDA\"]:\n            logger.warning(f\"[calculate_total_cost] Large SELL order of {symbol}, applying additional processing fee\", \n                          extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_total_cost'})\n            extra_fee = gross_proceeds * 0.02  # 2% extra\n            commission += extra_fee\n        \n        net_proceeds = gross_proceeds - commission - sec_fee\n        \n        logger.info(f\"[calculate_total_cost] SELL proceeds breakdown - Gross: ${gross_proceeds:.2f}, Commission: ${commission:.2f}, SEC Fee: ${sec_fee:.2f}, Net: ${net_proceeds:.2f}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'calculate_total_cost',\n                          'extra_data': {'gross_proceeds': gross_proceeds, 'commission': commission, 'sec_fee': sec_fee, 'net_proceeds': net_proceeds}})\n        \n        return {'base_amount': gross_proceeds, 'commission': commission, 'fees': sec_fee, 'total_cost': net_proceeds}",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Calculates comprehensive cost breakdown for trades. For BUY orders: base cost + commission + exchange fees = total debit. For SELL orders: gross proceeds - commission - SEC fees = net proceeds. Applies additional 2% fee for large SELL orders (>200 shares) of volatile stocks (TSLA, NVDA)."
  },
  {
    "id": 210,
    "name": "estimate_slippage",
    "type": "function",
    "current_summary": "Estimate price slippage based on order size and symbol volatility.",
    "snippet": "def estimate_slippage(quantity: int, symbol: str, order_type: OrderType, trace_id: str, order_id: str) -> float:\n    \"\"\"\n    Estimate price slippage based on order size and symbol volatility.\n    \n    Args:\n        quantity: Number of shares\n        symbol: Stock ticker symbol\n        order_type: BUY or SELL (currently unused)\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        float: Estimated slippage as a decimal percentage (e.g., 0.015 = 1.5%)\n    \n    Slippage Factors:\n        - Volatile symbols (TSLA, NVDA, META) have higher base slippage\n        - Quantity > 1000: 2x base slippage\n        - Quantity > 500: 1.5x base slippage\n        - Quantity â‰¤ 500: 1x base slippage\n    \n    Note:\n        Slippage represents expected price movement during order execution\n    \"\"\"\n    logger.info(f\"[estimate_slippage] Estimating slippage for {quantity} shares of {symbol}\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'estimate_slippage'})\n    \n    # Volatile stocks have higher slippage\n    volatile_symbols = {\"TSLA\": 0.015, \"NVDA\": 0.01, \"META\": 0.008}\n    base_slippage = volatile_symbols.get(symbol, 0.005)\n    \n    # Quantity impacts slippage\n    if quantity > 1000:\n        slippage = base_slippage * 2.0\n        logger.warning(f\"[estimate_slippage] High slippage expected for large order: {slippage*100:.2f}%\", \n                      extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'estimate_slippage'})\n    elif quantity > 500:\n        slippage = base_slippage * 1.5\n    else:\n        slippage = base_slippage\n    \n    logger.info(f\"[estimate_slippage] Estimated slippage: {slippage*100:.2f}%\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'estimate_slippage', \n                      'extra_data': {'slippage_pct': slippage}})\n    \n    return slippage",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Estimates price slippage based on order size and stock volatility. Volatile stocks (TSLA, NVDA, META) have higher base slippage. Large orders (>1000 shares) double the slippage. Returns percentage as decimal (e.g., 0.015 = 1.5%)."
  },
  {
    "id": 206,
    "name": "get_cost_basis",
    "type": "function",
    "current_summary": "Retrieve average cost basis for profit/loss calculations.",
    "snippet": "def get_cost_basis(symbol: str) -> float:\n    \"\"\"\n    Retrieve average cost basis for profit/loss calculations.\n    \n    Args:\n        symbol: Stock ticker symbol\n    \n    Returns:\n        float: Average purchase price for the symbol, defaults to $50.00 if unknown\n    \n    Note:\n        Cost basis represents the average price paid per share and is used\n        to calculate estimated P&L on SELL orders or unrealized gains on BUY orders\n    \"\"\"\n    cost_basis = {\n        \"AAPL\": 165.00,\n        \"GOOGL\": 135.00,\n        \"MSFT\": 360.00,\n        \"AMZN\": 145.00,\n        \"TSLA\": 230.00,\n        \"META\": 340.00,\n        \"NVDA\": 475.00\n    }\n    # Use default cost basis for unknown symbols\n    return cost_basis.get(symbol, 50.0)",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Returns average purchase price (cost basis) for a stock symbol. Used to calculate unrealized gains/losses. Contains hardcoded values for major stocks (AAPL: $165, NVDA: $475, etc). Defaults to $50 for unknown symbols."
  },
  {
    "id": 215,
    "name": "get_current_price",
    "type": "function",
    "current_summary": "Get current market price for a symbol",
    "snippet": "def get_current_price(symbol: str, request: Request):\n    \"\"\"Get current market price for a symbol\"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    logger.info(\"[get_current_price] Fetching current price\", extra={\n        \"trace_id\": trace_id,\n        \"symbol\": symbol,\n        \"function\": \"get_current_price\"\n    })\n    \n    try:\n        price = get_market_price(symbol)\n        return {\n            \"symbol\": symbol,\n            \"price\": price,\n            \"timestamp\": datetime.now().isoformat()\n        }\n    except Exception as e:\n        logger.exception(\"[get_current_price] Error fetching price\", extra={\n            \"trace_id\": trace_id,\n            \"symbol\": symbol,\n            \"function\": \"get_current_price\",\n            \"extra_data\": {\"error\": str(e), \"error_type\": type(e).__name__}\n        })\n        raise HTTPException(status_code=500, detail=\"Unable to fetch price\")",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Endpoint to fetch current market price for a stock symbol. Returns price and timestamp. Raises 500 error if price lookup fails."
  },
  {
    "id": 205,
    "name": "get_market_price",
    "type": "function",
    "current_summary": "Retrieve current market price for a trading symbol with simulated variance.",
    "snippet": "def get_market_price(symbol: str, scenario: Optional[str] = None) -> float:\n    \"\"\"\n    Retrieve current market price for a trading symbol with simulated variance.\n    \n    Args:\n        symbol: Stock ticker symbol (e.g., 'AAPL', 'NVDA')\n        scenario: Optional scenario identifier (reserved for future use)\n    \n    Returns:\n        float: Current market price rounded to 2 decimal places\n    \n    Raises:\n        ValueError: If symbol is not found in supported symbols list\n    \n    Note:\n        - Applies Â±2% random variance to base price for realistic market simulation\n        - Simulates real-time price fluctuations between service calls\n        - Used for both validation and execution pricing\n    \"\"\"\n    base_prices = {\n        \"AAPL\": 175.50,\n        \"GOOGL\": 140.25,\n        \"MSFT\": 378.90,\n        \"AMZN\": 152.75,\n        \"TSLA\": 242.80,\n        \"META\": 356.20,\n        \"NVDA\": 495.60\n    }\n    \n    # Get base price - no default, should fail for unknown\n    if symbol not in base_prices:\n        raise ValueError(f\"Symbol '{symbol}' not found in market data\")\n    \n    base_price = base_prices[symbol]\n    \n    # Apply market variance for realistic price simulation\n    # Mimics real-world price movements between service calls\n    variance = random.uniform(-0.02, 0.02)\n    price = base_price * (1 + variance)\n    \n    return round(price, 2)",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Retrieves current market price for stock symbols with simulated variance. Returns base price plus random Â±2% fluctuation to mimic real market movements. Raises ValueError if symbol not found in supported list (AAPL, GOOGL, MSFT, AMZN, TSLA, META, NVDA)."
  },
  {
    "id": 216,
    "name": "get_pnl",
    "type": "function",
    "current_summary": "Get PnL data for a specific order",
    "snippet": "def get_pnl(order_id: str, request: Request):\n    \"\"\"Get PnL data for a specific order\"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    logger.info(\"[get_pnl] Fetching PnL data\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": order_id,\n        \"function\": \"get_pnl\"\n    })\n    \n    pricing = pricing_data.get(order_id)\n    if not pricing:\n        logger.warning(\"[get_pnl] PnL data not found\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": order_id,\n            \"function\": \"get_pnl\"\n        })\n        raise HTTPException(status_code=404, detail=\"PnL data not found\")\n    \n    return {\n        \"order_id\": order_id,\n        \"estimated_pnl\": pricing.get(\"estimated_pnl\"),\n        \"total_cost\": pricing.get(\"total_cost\"),\n        \"symbol\": pricing.get(\"symbol\")\n    }",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Retrieves stored PnL data for a completed order. Returns estimated_pnl, total_cost, and symbol. Raises 404 if order not found in pricing database."
  },
  {
    "id": 214,
    "name": "get_pricing",
    "type": "function",
    "current_summary": "Get pricing data for a specific order",
    "snippet": "def get_pricing(order_id: str, request: Request):\n    \"\"\"Get pricing data for a specific order\"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    logger.info(\"[get_pricing] Fetching pricing data\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": order_id,\n        \"function\": \"get_pricing\"\n    })\n    \n    pricing = pricing_data.get(order_id)\n    if not pricing:\n        logger.warning(\"[get_pricing] Pricing data not found\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": order_id,\n            \"function\": \"get_pricing\"\n        })\n        raise HTTPException(status_code=404, detail=\"Pricing data not found\")\n    \n    return pricing",
    "filePath": "..\\trade-platform\\pricing_pnl_service\\src\\app.py",
    "serviceName": "pricing_pnl_service",
    "new_summary": "Retrieves complete pricing data for a specific order including price, quantity, PnL, and total cost. Raises 404 if order not found in pricing database."
  },
  {
    "id": 217,
    "name": "OrderType",
    "type": "class",
    "current_summary": "Class in risk_service",
    "snippet": "class OrderType(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Enum defining valid order types in risk service: BUY or SELL. Used to apply order-specific risk scoring (e.g., selling at loss vs buying at peak)."
  },
  {
    "id": 219,
    "name": "RiskAssessmentRequest",
    "type": "class",
    "current_summary": "Class in risk_service",
    "snippet": "class RiskAssessmentRequest(BaseModel):\n    order_id: str\n    symbol: str = Field(..., example=\"AAPL\")\n    quantity: int = Field(...)\n    price: float = Field(..., gt=0)\n    pnl: float\n    order_type: OrderType",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Request model for risk assessment. Contains order details (symbol, quantity, price) plus calculated PnL from pricing service. Used by orchestrator to request risk evaluation before trade execution."
  },
  {
    "id": 220,
    "name": "RiskAssessmentResponse",
    "type": "class",
    "current_summary": "Class in risk_service",
    "snippet": "class RiskAssessmentResponse(BaseModel):\n    order_id: str\n    risk_level: RiskLevel\n    approved: bool\n    risk_score: float\n    risk_factors: Dict[str, Any]\n    recommendation: str\n    timestamp: str",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Response model for risk assessment. Returns risk level (LOW/MEDIUM/HIGH), approval decision, numeric risk score (0-100), detailed risk factors breakdown, recommendation message, and timestamp. Used by orchestrator to decide whether to proceed with trade."
  },
  {
    "id": 218,
    "name": "RiskLevel",
    "type": "class",
    "current_summary": "Class in risk_service",
    "snippet": "class RiskLevel(str, Enum):\n    LOW = \"LOW\"\n    MEDIUM = \"MEDIUM\"\n    HIGH = \"HIGH\"",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Enum defining risk severity levels: LOW (safe to proceed), MEDIUM (proceed with caution), HIGH (reject trade). Used to categorize risk assessment results."
  },
  {
    "id": 221,
    "name": "assess_order_risk",
    "type": "function",
    "current_summary": "Evaluate order-type specific risk factors.",
    "snippet": "def assess_order_risk(symbol: str, quantity: int, price: float, pnl: float, order_type: OrderType, trace_id: str, order_id: str) -> Dict[str, Any]:\n    \"\"\"\n    Evaluate order-type specific risk factors.\n    \n    Args:\n        symbol: Stock ticker symbol\n        quantity: Number of shares\n        price: Price per share\n        pnl: Estimated profit/loss\n        order_type: BUY or SELL\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        dict: Risk assessment with keys:\n            - 'risk_points': Total risk points for order-specific factors\n            - 'factors': Dictionary of individual risk factor scores\n    \n    Risk Factors:\n        BUY orders:\n            - Large position risk (>$100K): 15 points\n            - Expensive purchase (PnL < -$5000): 10 points\n        \n        SELL orders:\n            - Selling at loss (negative PnL): 15-20 points based on loss amount\n            - Large liquidation (>$50K): 10 points\n    \"\"\"\n    logger.info(f\"[assess_order_risk] Assessing {order_type} order risks\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'assess_order_risk'})\n    \n    risk_points = 0\n    factors = {}\n    position_value = quantity * price\n    \n    if order_type == OrderType.BUY:\n        # Check if buying at peak price\n        if position_value > 100000:\n            risk_points += 15\n            factors['large_position_risk'] = 15\n            logger.warning(\"[assess_order_risk] Large BUY position detected, elevated risk\", \n                          extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'assess_order_risk'})\n        \n        # Check negative PnL on purchase (buying expensive)\n        if pnl < -5000:\n            risk_points += 10\n            factors['expensive_purchase_risk'] = 10\n            logger.warning(f\"[assess_order_risk] Buying at high cost, PnL impact: ${pnl:.2f}\", \n                          extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'assess_order_risk'})\n    else:  # SELL\n        # Check if selling at loss\n        if pnl < 0:\n            risk_points += 20\n            factors['loss_realization_risk'] = 20\n            logger.error(f\"[assess_order_risk] SELLING AT LOSS detected: ${pnl:.2f}\", \n                        extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'assess_order_risk'})\n        \n        # Check large position liquidation\n        if position_value > 50000:\n            risk_points += 10\n            factors['large_liquidation_risk'] = 10\n            logger.warning(\"[assess_order_risk] Large position liquidation, market impact risk\", \n                          extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'assess_order_risk'})\n    \n    logger.info(f\"[assess_order_risk] {order_type} risk assessment: {risk_points} points\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'assess_order_risk',\n                      'extra_data': {'risk_points': risk_points, 'factors': factors}})\n    \n    return {'risk_points': risk_points, 'factors': factors}",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Evaluates order-type specific risks. For BUY: flags large positions (>$100K) and expensive purchases (PnL < -$5000). For SELL: flags loss realization (negative PnL) and large liquidations (>$50K). Returns risk points and detailed factor breakdown."
  },
  {
    "id": 228,
    "name": "assess_risk",
    "type": "function",
    "current_summary": "Perform comprehensive risk assessment on a trade order",
    "snippet": "def assess_risk(request_data: RiskAssessmentRequest, request: Request):\n    \"\"\"\n    Perform comprehensive risk assessment on a trade order\n    Evaluates multiple risk factors and provides approval/rejection recommendation\n    \"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    # Create trace-specific log file\n    get_trace_logger(trace_id)\n    \n    logger.info(\"[assess_risk] Risk assessment request received\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk'})\n    logger.info(f\"[assess_risk] Assessing risk for - Symbol: {request_data.symbol}, Quantity: {request_data.quantity}, Price: ${request_data.price}, PnL: ${request_data.pnl}, Type: {request_data.order_type}\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": request_data.order_id,\n        \"function\": \"assess_risk\",\n        \"symbol\": request_data.symbol,\n        \"quantity\": request_data.quantity,\n        \"price\": request_data.price\n    })\n    \n    try:\n        # Step 1: Validate compliance rules\n        logger.info(\"[assess_risk] Step 1: Validating compliance rules\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk'})\n        \n        compliance_ok, compliance_reason = validate_compliance_rules(\n            request_data.symbol, request_data.quantity, request_data.price, \n            request_data.order_type, trace_id, request_data.order_id\n        )\n        \n        if not compliance_ok:\n            logger.error(f\"[assess_risk] Compliance check failed: {compliance_reason}\", \n                        extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk'})\n            raise HTTPException(status_code=403, detail=f\"Compliance validation failed: {compliance_reason}\")\n        \n        # Step 2: Check sector limits\n        logger.info(\"[assess_risk] Step 2: Checking sector exposure limits\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk'})\n        sector_ok, sector_reason = check_sector_limits(request_data.symbol, trace_id, request_data.order_id)\n        \n        # Step 3: Order type specific risk assessment\n        logger.info(\"[assess_risk] Step 3: Performing order type specific risk assessment\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk'})\n        \n        logger.info(f\"[assess_risk] Analyzing {request_data.order_type.value} order risks\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk'})\n        order_risk = assess_order_risk(request_data.symbol, request_data.quantity, request_data.price, \n                                      request_data.pnl, request_data.order_type, trace_id, request_data.order_id)\n        \n        # Step 4: Calculate overall risk score\n        logger.info(\"[assess_risk] Step 4: Calculating comprehensive risk score\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk'})\n        logger.info(\"[assess_risk] calculate_risk_score processing...\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_risk_score'})\n        \n        # Simulate slow processing for high-value orders\n        position_value = abs(request_data.quantity * request_data.price)\n        if position_value > 500000:\n            logger.info(f\"[assess_risk] High-value order detected (${position_value:.2f}), performing extended risk analysis...\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk'})\n            time.sleep(6)  # Takes too long, will timeout\n        \n        # PnL integrity check - detect if PnL calculation seems wrong\n        pnl_ratio = abs(request_data.pnl) / position_value if position_value > 0 else 0\n        \n        # Additional check: For SELL orders, verify PnL makes sense\n        if request_data.order_type == \"SELL\" and request_data.pnl < 0:\n            loss_percentage = abs(request_data.pnl) / position_value * 100\n            if loss_percentage > 15:\n                logger.error(f\"[assess_risk] Detected upstream calculation error - SELL order showing {loss_percentage:.1f}% loss\", extra={\n                    'trace_id': trace_id,\n                    'order_id': request_data.order_id,\n                    'function': 'assess_risk',\n                    'extra_data': {\n                        'detection_service': 'risk_service',\n                        'suspected_source': 'pricing_service_pnl_calculation',\n                        'order_type': 'SELL',\n                        'quantity': request_data.quantity,\n                        'sell_price': request_data.price,\n                        'received_pnl': request_data.pnl,\n                        'position_value': position_value,\n                        'loss_percentage': loss_percentage,\n                        'issue': 'SELL orders should profit when current price > cost basis, but showing large loss',\n                        'recommendation': 'Check pricing service calculate_pnl() function for SELL order logic'\n                    }\n                })\n                raise HTTPException(\n                    status_code=422,\n                    detail=f\"Risk service blocked execution: Received invalid PnL data from pricing service. SELL order (qty={request_data.quantity}, price=${request_data.price}) shows unrealistic loss of ${request_data.pnl} ({loss_percentage:.1f}%). SELL orders should profit when sell price exceeds cost basis. Upstream pricing calculation error suspected.\"\n                )\n        \n        if pnl_ratio > 0.15:  # PnL shouldn't exceed 15% of position value in normal cases\n            logger.error(f\"[assess_risk] PnL integrity check failed - PnL (${request_data.pnl}) is {pnl_ratio*100:.1f}% of position value (${position_value})\", extra={\n                'trace_id': trace_id,\n                'order_id': request_data.order_id,\n                'function': 'assess_risk',\n                'extra_data': {\n                    'pnl': request_data.pnl,\n                    'position_value': position_value,\n                    'pnl_ratio': pnl_ratio,\n                    'threshold': 0.15,\n                    'check_failed': 'pnl_integrity'\n                }\n            })\n            raise HTTPException(\n                status_code=422,\n                detail=f\"Risk assessment failed: PnL calculation integrity check failed. Estimated PnL (${request_data.pnl}) appears inconsistent with position value (${position_value}). Please verify pricing calculations.\"\n            )\n        \n        risk_score, risk_factors = calculate_risk_score(\n            request_data.symbol,\n            request_data.quantity,\n            request_data.price,\n            request_data.pnl,\n            request_data.order_type\n        )\n        \n        logger.info(f\"[calculate_risk_score] Risk factors breakdown:\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_risk_score', 'extra_data': risk_factors})\n        logger.info(f\"[calculate_risk_score]   - Position size risk: {risk_factors.get('position_size_risk')} points (Position value: ${risk_factors.get('position_value'):.2f})\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_risk_score'})\n        logger.info(f\"[calculate_risk_score]   - PnL risk: {risk_factors.get('pnl_risk')} points (Estimated PnL: ${risk_factors.get('estimated_pnl'):.2f})\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_risk_score'})\n        logger.info(f\"[calculate_risk_score]   - Quantity risk: {risk_factors.get('quantity_risk')} points (Quantity: {risk_factors.get('quantity')})\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_risk_score'})\n        logger.info(f\"[calculate_risk_score]   - Volatility risk: {risk_factors.get('volatility_risk')} points (Symbol: {risk_factors.get('symbol')})\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_risk_score'})\n        logger.info(f\"[calculate_risk_score] Total risk score calculated: {risk_score:.1f}/100\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'calculate_risk_score', 'extra_data': {'risk_score': risk_score}})\n        \n        # Determine risk level\n        risk_level = determine_risk_level(risk_score)\n        logger.info(f\"[determine_risk_level] Risk level determined: {risk_level.value}\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'determine_risk_level', 'extra_data': {'risk_level': risk_level.value}})\n        \n        # Determine approval\n        # HIGH risk trades are rejected, others are approved\n        approved = risk_level != RiskLevel.HIGH\n        logger.info(f\"[assess_risk] Approval decision: {'APPROVED' if approved else 'REJECTED'} (Risk level: {risk_level.value})\", \n                   extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'assess_risk', 'extra_data': {'approved': approved, 'risk_level': risk_level.value}})\n        \n        # Get recommendation\n        recommendation = get_recommendation(risk_level, risk_score)\n        logger.info(f\"[get_recommendation] Risk recommendation: {recommendation}\", extra={'trace_id': trace_id, 'order_id': request_data.order_id, 'function': 'get_recommendation'})\n        \n        timestamp = datetime.now().isoformat()\n        \n        # Store risk assessment\n        risk_assessments[request_data.order_id] = {\n            \"order_id\": request_data.order_id,\n            \"risk_level\": risk_level.value,\n            \"approved\": approved,\n            \"risk_score\": risk_score,\n            \"risk_factors\": risk_factors,\n            \"recommendation\": recommendation,\n            \"timestamp\": timestamp\n        }\n        \n        logger.info(\"[assess_risk] Risk assessment completed\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": request_data.order_id,\n            \"function\": \"assess_risk\",\n            'extra_data': {\n                'risk_level': risk_level.value,\n                'risk_score': risk_score,\n                'approved': approved,\n                'recommendation': recommendation\n            }\n        })\n        \n        return RiskAssessmentResponse(\n            order_id=request_data.order_id,\n            risk_level=risk_level,\n            approved=approved,\n            risk_score=risk_score,\n            risk_factors=risk_factors,\n            recommendation=recommendation,\n            timestamp=timestamp\n        )\n        \n    except Exception as e:\n        logger.exception(\"[assess_risk] Unexpected error in risk assessment\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": request_data.order_id,\n            \"function\": \"assess_risk\",\n            \"extra_data\": {\"error\": str(e), \"error_type\": type(e).__name__}\n        })\n        raise HTTPException(status_code=500, detail=f\"Risk assessment failed: {str(e)}\")",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Main risk assessment endpoint. Performs comprehensive 4-step evaluation: (1) validates compliance rules, (2) checks sector exposure limits, (3) assesses order-specific risks, (4) calculates overall risk score. Includes PnL integrity checks to detect upstream calculation errors. Blocks high-risk trades (score â‰¥70) and approves others. Simulates slow processing (6s delay) for high-value orders (>$500K) that may timeout."
  },
  {
    "id": 225,
    "name": "calculate_risk_score",
    "type": "function",
    "current_summary": "Calculate comprehensive risk score using multi-factor analysis.",
    "snippet": "def calculate_risk_score(\n    symbol: str,\n    quantity: int,\n    price: float,\n    pnl: float,\n    order_type: OrderType\n) -> tuple[float, Dict[str, Any]]:\n    \"\"\"\n    Calculate comprehensive risk score using multi-factor analysis.\n    \n    Args:\n        symbol: Stock ticker symbol\n        quantity: Number of shares\n        price: Price per share\n        pnl: Estimated profit/loss\n        order_type: BUY or SELL (currently unused in calculation)\n    \n    Returns:\n        tuple: (risk_score, risk_factors_dict)\n            - risk_score: Total risk score (0-100, higher = riskier)\n            - risk_factors_dict: Detailed breakdown of all risk components\n    \n    Risk Components (max 100 points):\n        1. Position Size Risk (0-30 points):\n           - > $100K: 30 pts | $50K-$100K: 20 pts | $10K-$50K: 10 pts | < $10K: 5 pts\n        \n        2. P&L Risk (0-30 points):\n           - < -$5000: 30 pts | -$5000 to -$1000: 20 pts | -$1000 to $0: 10 pts\n           - > $10,000 profit: 15 pts | else: 5 pts\n        \n        3. Quantity Risk (0-20 points):\n           - > 500 shares: 20 pts | 200-500: 15 pts | 100-200: 10 pts | < 100: 5 pts\n        \n        4. Volatility Risk (0-20 points):\n           - TSLA: 20 pts | NVDA: 15 pts | META: 10 pts | Others: 5 pts\n    \"\"\"\n    risk_score = 0\n    risk_factors = {}\n    \n    # Factor 1: Position size risk (0-30 points)\n    # Large positions are riskier\n    position_value = quantity * price\n    \n    # Add detailed logging for debugging\n    if position_value > 100000:\n        position_risk = 30\n    elif position_value > 50000:\n        position_risk = 20\n    elif position_value > 10000:\n        position_risk = 10\n    else:\n        position_risk = 5\n    \n    risk_score += position_risk\n    risk_factors[\"position_size_risk\"] = position_risk\n    risk_factors[\"position_value\"] = position_value\n    risk_factors[\"position_risk_logic\"] = f\"position_value ${position_value:.2f} â†’ {position_risk} points\"\n    \n    # Factor 2: PnL risk (0-30 points)\n    # Negative PnL or large PnL values are riskier\n    if pnl < -5000:\n        pnl_risk = 30\n    elif pnl < -1000:\n        pnl_risk = 20\n    elif pnl < 0:\n        pnl_risk = 10\n    elif pnl > 10000:\n        pnl_risk = 15  # Very high gains also carry risk\n    else:\n        pnl_risk = 5\n    \n    risk_score += pnl_risk\n    risk_factors[\"pnl_risk\"] = pnl_risk\n    risk_factors[\"estimated_pnl\"] = pnl\n    risk_factors[\"pnl_risk_logic\"] = f\"pnl ${pnl:.2f} â†’ {pnl_risk} points\"\n    \n    # Factor 3: Quantity risk (0-20 points)\n    # Larger quantities carry higher execution risk\n    if quantity > 500:\n        quantity_risk = 20\n    elif quantity > 200:\n        quantity_risk = 15\n    elif quantity > 100:\n        quantity_risk = 10\n    else:\n        quantity_risk = 5\n    \n    risk_score += quantity_risk\n    risk_factors[\"quantity_risk\"] = quantity_risk\n    risk_factors[\"quantity\"] = quantity\n    risk_factors[\"quantity_risk_logic\"] = f\"quantity {quantity} â†’ {quantity_risk} points\"\n    \n    # Factor 4: Symbol volatility risk (0-20 points)\n    # Some symbols are considered more volatile\n    volatile_symbols = {\"TSLA\": 20, \"NVDA\": 15, \"META\": 10}\n    volatility_risk = volatile_symbols.get(symbol, 5)\n    \n    risk_score += volatility_risk\n    risk_factors[\"volatility_risk\"] = volatility_risk\n    risk_factors[\"symbol\"] = symbol\n    risk_factors[\"volatility_risk_logic\"] = f\"symbol {symbol} â†’ {volatility_risk} points (volatile={symbol in volatile_symbols})\"\n    risk_factors[\"total_risk_score\"] = risk_score\n    \n    return risk_score, risk_factors",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Calculates comprehensive risk score (0-100) using multi-factor analysis. Factors: position size risk (0-30 pts based on order value), PnL risk (0-30 pts for losses or extreme gains), quantity risk (0-20 pts for large orders), volatility risk (0-20 pts for volatile stocks). Returns total score and detailed factor breakdown."
  },
  {
    "id": 222,
    "name": "check_portfolio_concentration",
    "type": "function",
    "current_summary": "Analyze portfolio concentration risk for the position.",
    "snippet": "def check_portfolio_concentration(symbol: str, quantity: int, price: float, trace_id: str, order_id: str) -> tuple[float, Dict[str, Any]]:\n    \"\"\"\n    Analyze portfolio concentration risk for the position.\n    \n    Args:\n        symbol: Stock ticker symbol\n        quantity: Number of shares\n        price: Price per share\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        tuple: (concentration_risk_points, details_dict)\n            - concentration_risk_points: Risk score (0-20)\n            - details_dict: Contains 'concentration_pct' and 'position_value'\n    \n    Risk Thresholds:\n        - Concentration > 10% of portfolio: 20 risk points\n        - Concentration > 5% of portfolio: 10 risk points\n        - Concentration â‰¤ 5% of portfolio: 0 risk points\n    \n    Note:\n        Assumes a $1M portfolio value for simulation\n    \"\"\"\n    logger.info(\"[check_portfolio_concentration] Analyzing portfolio concentration\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_portfolio_concentration'})\n    \n    # Simulated portfolio (in real system, would query portfolio service)\n    portfolio_value = 1000000  # $1M portfolio\n    position_value = quantity * price\n    concentration = (position_value / portfolio_value) * 100\n    \n    concentration_risk = 0\n    if concentration > 10:\n        concentration_risk = 20\n        logger.warning(f\"[check_portfolio_concentration] High concentration: {concentration:.1f}% of portfolio\", \n                      extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_portfolio_concentration'})\n    elif concentration > 5:\n        concentration_risk = 10\n    else:\n        concentration_risk = 0\n    \n    logger.info(f\"[check_portfolio_concentration] Concentration risk: {concentration_risk} points ({concentration:.1f}% of portfolio)\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_portfolio_concentration', \n                      'extra_data': {'concentration_pct': concentration, 'risk_points': concentration_risk}})\n    \n    return concentration_risk, {'concentration_pct': concentration, 'position_value': position_value}",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Analyzes portfolio concentration risk by calculating position value as percentage of total portfolio ($1M simulated). Assigns risk points: 20 pts if >10% concentration, 10 pts if >5%, 0 pts otherwise. Helps prevent over-concentration in single positions."
  },
  {
    "id": 223,
    "name": "check_sector_limits",
    "type": "function",
    "current_summary": "Validate sector exposure limits and trigger compliance checks if needed.",
    "snippet": "def check_sector_limits(symbol: str, trace_id: str, order_id: str) -> tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate sector exposure limits and trigger compliance checks if needed.\n    \n    Args:\n        symbol: Stock ticker symbol\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        tuple: (is_valid, error_message)\n            - is_valid: Always True (warnings only, no blocking)\n            - error_message: Always None\n    \n    Side Effects:\n        - For Technology sector positions when exposure > 40%:\n          Triggers 3-second deep compliance check (simulated database query)\n        - Logs warnings for high sector concentration\n    \"\"\"\n    logger.info(f\"[check_sector_limits] Checking sector limits for {symbol}\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_sector_limits'})\n    \n    sector_map = {\n        \"AAPL\": \"Technology\", \"GOOGL\": \"Technology\", \"MSFT\": \"Technology\",\n        \"NVDA\": \"Technology\", \"META\": \"Technology\",\n        \"TSLA\": \"Automotive\", \"AMZN\": \"Consumer\"\n    }\n    \n    sector = sector_map.get(symbol, \"Unknown\")\n    \n    # Simulated sector exposure (in real system, would query portfolio service)\n    current_tech_exposure = 0.45  # 45% of portfolio in tech\n    \n    # Perform enhanced compliance check for concentrated sector positions\n    # Required for positions exceeding 40% sector concentration per regulatory guidelines\n    if sector == \"Technology\" and current_tech_exposure > 0.40:\n        logger.warning(f\"[check_sector_limits] Technology sector exposure high: {current_tech_exposure*100:.1f}%, running deep compliance check...\", \n                      extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_sector_limits'})\n        compliance_start = time.time()\n        time.sleep(3)  # Simulating slow compliance database query\n        compliance_duration_ms = int((time.time() - compliance_start) * 1000)\n        logger.info(f\"[check_sector_limits] Deep compliance check completed in {compliance_duration_ms}ms\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_sector_limits', 'extra_data': {'duration_ms': compliance_duration_ms, 'sector': sector, 'exposure': current_tech_exposure}})\n        # Don't block, just warn\n    \n    logger.info(f\"[check_sector_limits] Sector check passed for {symbol} (Sector: {sector})\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_sector_limits'})\n    return True, None",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Validates sector exposure limits and triggers deep compliance checks for concentrated positions. For Technology sector with >40% exposure, performs 3-second database query to verify compliance. Always returns True (warnings only, no blocking) but logs concerns for audit trail."
  },
  {
    "id": 226,
    "name": "determine_risk_level",
    "type": "function",
    "current_summary": "Map numeric risk score to categorical risk level.",
    "snippet": "def determine_risk_level(risk_score: float) -> RiskLevel:\n    \"\"\"\n    Map numeric risk score to categorical risk level.\n    \n    Args:\n        risk_score: Numeric risk score (0-100)\n    \n    Returns:\n        RiskLevel: HIGH, MEDIUM, or LOW\n    \n    Thresholds:\n        - score â‰¥ 70: HIGH\n        - 40 â‰¤ score < 70: MEDIUM\n        - score < 40: LOW\n    \"\"\"\n    # Risk level thresholds: HIGH >= 70, MEDIUM >= 40, LOW < 40\n    if risk_score >= 70:\n        return RiskLevel.HIGH\n    elif risk_score >= 40:\n        return RiskLevel.MEDIUM\n    else:\n        return RiskLevel.LOW",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Maps numeric risk score to categorical level. HIGH (â‰¥70): reject trade, MEDIUM (40-69): proceed with caution, LOW (<40): approve normally. Used to make binary approval decisions from continuous risk scores."
  },
  {
    "id": 227,
    "name": "get_recommendation",
    "type": "function",
    "current_summary": "Generate human-readable risk recommendation.",
    "snippet": "def get_recommendation(risk_level: RiskLevel, risk_score: float) -> str:\n    \"\"\"\n    Generate human-readable risk recommendation.\n    \n    Args:\n        risk_level: Categorical risk level (HIGH, MEDIUM, LOW)\n        risk_score: Numeric risk score for context\n    \n    Returns:\n        str: Recommendation message with score and suggested action\n    \n    Recommendations:\n        - HIGH: Advise reduction or rejection\n        - MEDIUM: Proceed with caution and close monitoring\n        - LOW: Approve with normal monitoring\n    \"\"\"\n    if risk_level == RiskLevel.HIGH:\n        return f\"HIGH RISK (score: {risk_score:.1f}) - Consider reducing position size or rejecting trade\"\n    elif risk_level == RiskLevel.MEDIUM:\n        return f\"MEDIUM RISK (score: {risk_score:.1f}) - Proceed with caution, monitor closely\"\n    else:\n        return f\"LOW RISK (score: {risk_score:.1f}) - Trade approved with normal monitoring\"",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Generates human-readable risk recommendation based on risk level and score. Provides actionable guidance: HIGH risk suggests rejection/reduction, MEDIUM suggests caution/monitoring, LOW approves with standard monitoring."
  },
  {
    "id": 229,
    "name": "get_risk_assessment",
    "type": "function",
    "current_summary": "Get risk assessment for a specific order",
    "snippet": "def get_risk_assessment(order_id: str, request: Request):\n    \"\"\"Get risk assessment for a specific order\"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    logger.info(\"[get_risk_assessment] Fetching risk assessment\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": order_id,\n        \"function\": \"get_risk_assessment\"\n    })\n    \n    assessment = risk_assessments.get(order_id)\n    if not assessment:\n        logger.warning(\"[get_risk_assessment] Risk assessment not found\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": order_id,\n            \"function\": \"get_risk_assessment\"\n        })\n        raise HTTPException(status_code=404, detail=\"Risk assessment not found\")\n    \n    return assessment",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Retrieves previously calculated risk assessment for an order. Returns risk level, score, factors, and approval status. Raises 404 if assessment not found."
  },
  {
    "id": 230,
    "name": "list_risk_assessments",
    "type": "function",
    "current_summary": "List all risk assessments",
    "snippet": "def list_risk_assessments(request: Request):\n    \"\"\"List all risk assessments\"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    logger.info(\"[list_risk_assessments] Listing all risk assessments\", extra={\n        \"trace_id\": trace_id,\n        \"count\": len(risk_assessments),\n        \"function\": \"list_risk_assessments\"\n    })\n    \n    return {\n        \"assessments\": list(risk_assessments.values()),\n        \"count\": len(risk_assessments)\n    }",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Lists all stored risk assessments with count. Used for audit trails and historical risk analysis."
  },
  {
    "id": 224,
    "name": "validate_compliance_rules",
    "type": "function",
    "current_summary": "Validate order against compliance and regulatory requirements.",
    "snippet": "def validate_compliance_rules(symbol: str, quantity: int, price: float, order_type: OrderType, \n                             trace_id: str, order_id: str) -> tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate order against compliance and regulatory requirements.\n    \n    Args:\n        symbol: Stock ticker symbol\n        quantity: Number of shares\n        price: Price per share\n        order_type: BUY or SELL\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        tuple: (is_compliant, error_message)\n            - is_compliant: True if all checks pass, False otherwise\n            - error_message: None if compliant, error description if not\n    \n    Compliance Checks:\n        1. Single trade limit: Order value must not exceed $500,000\n        2. Restricted stocks: Symbol must not be on restricted list\n    \n    Note:\n        Failed compliance checks result in order rejection\n    \"\"\"\n    logger.info(\"[validate_compliance_rules] Running compliance checks\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_compliance_rules'})\n    \n    position_value = quantity * price\n    \n    # Check single order size limit ($500K)\n    if position_value > 500000:\n        logger.error(f\"[validate_compliance_rules] Order exceeds single trade limit: ${position_value:.2f} > $500,000\", \n                    extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_compliance_rules'})\n        return False, f\"Order value ${position_value:.2f} exceeds single trade limit of $500,000\"\n    \n    # Check restricted stocks (simulated)\n    restricted_stocks = []  # Would come from compliance database\n    if symbol in restricted_stocks:\n        logger.error(f\"[validate_compliance_rules] Symbol {symbol} is currently restricted\", \n                    extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_compliance_rules'})\n        return False, f\"Symbol {symbol} is currently restricted for trading\"\n    \n    logger.info(\"[validate_compliance_rules] All compliance checks passed\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_compliance_rules'})\n    return True, None",
    "filePath": "..\\trade-platform\\risk_service\\src\\app.py",
    "serviceName": "risk_service",
    "new_summary": "Validates orders against compliance rules. Checks: (1) single trade limit ($500K maximum), (2) restricted stock list. Returns False with error message if any check fails, True if compliant. Critical for regulatory compliance."
  },
  {
    "id": 231,
    "name": "OrderType",
    "type": "class",
    "current_summary": "Class in trade_service",
    "snippet": "class OrderType(str, Enum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Enum defining valid order types in trade service: BUY or SELL. Used throughout trade validation and execution logic."
  },
  {
    "id": 233,
    "name": "TradeExecutionRequest",
    "type": "class",
    "current_summary": "Class in trade_service",
    "snippet": "class TradeExecutionRequest(BaseModel):\n    order_id: str\n    symbol: str\n    quantity: int\n    price: float\n    order_type: OrderType",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Request model for trade execution. Contains order_id, symbol, quantity, price (from pricing service), and order_type. Used by orchestrator after risk approval to execute the final trade."
  },
  {
    "id": 235,
    "name": "TradeExecutionResponse",
    "type": "class",
    "current_summary": "Class in trade_service",
    "snippet": "class TradeExecutionResponse(BaseModel):\n    order_id: str\n    status: str\n    execution_time: str\n    symbol: str\n    quantity: int\n    price: float",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Response model for trade execution. Returns order_id, execution status, timestamp, and trade details (symbol, quantity, price). Confirms successful trade booking in system."
  },
  {
    "id": 232,
    "name": "TradeValidationRequest",
    "type": "class",
    "current_summary": "Class in trade_service",
    "snippet": "class TradeValidationRequest(BaseModel):\n    order_id: str\n    symbol: str = Field(..., example=\"AAPL\")\n    quantity: int = Field(...)\n    order_type: OrderType",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Request model for trade validation. Contains order_id, symbol, quantity, and order_type. First step in trade workflow to check feasibility before pricing and risk assessment."
  },
  {
    "id": 234,
    "name": "TradeValidationResponse",
    "type": "class",
    "current_summary": "Class in trade_service",
    "snippet": "class TradeValidationResponse(BaseModel):\n    valid: bool\n    reason: Optional[str] = None\n    order_id: str\n    normalized_quantity: int\n    timestamp: str",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Response model for trade validation. Returns validation result (valid/invalid), rejection reason if invalid, normalized quantity (adjusted to lot size), and timestamp. Orchestrator uses this to decide whether to proceed with order."
  },
  {
    "id": 243,
    "name": "check_order_limits",
    "type": "function",
    "current_summary": "Validate order quantity against exchange and global limits.",
    "snippet": "def check_order_limits(quantity: int, symbol: str, trace_id: str, order_id: str) -> tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate order quantity against exchange and global limits.\n    \n    Args:\n        quantity: Number of shares to trade\n        symbol: Stock ticker symbol\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        tuple: (is_valid, error_message)\n            - is_valid: True if within limits, False otherwise\n            - error_message: None if valid, error description if exceeded\n    \n    Limits Checked:\n        1. Symbol-specific maximum (varies by symbol, typically 3K-10K shares)\n        2. Global maximum: 10,000 shares per order\n    \n    Note:\n        Global limit takes precedence if no symbol-specific metadata exists\n    \"\"\"\n    logger.info(f\"[check_order_limits] Checking limits for {quantity} shares of {symbol}\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_order_limits'})\n    \n    metadata = get_symbol_metadata(symbol)\n    if metadata:\n        max_order = metadata['max_order']\n        if quantity > max_order:\n            logger.warning(f\"[check_order_limits] Order quantity {quantity} exceeds maximum {max_order} for {symbol}\", \n                          extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_order_limits', \n                                 'extra_data': {'quantity': quantity, 'max_allowed': max_order}})\n            return False, f\"Order quantity {quantity} exceeds maximum allowed {max_order} for {symbol}\"\n    \n    # Global limit check\n    if quantity > 10000:\n        logger.error(f\"[check_order_limits] Order quantity {quantity} exceeds global maximum 10000\", \n                    extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_order_limits'})\n        return False, f\"Order quantity {quantity} exceeds global maximum limit of 10000\"\n    \n    logger.info(f\"[check_order_limits] Order limits check passed\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_order_limits'})\n    return True, None",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Validates order quantity against exchange limits. Checks symbol-specific maximum (varies: AAPL 10K, TSLA 3K) and global maximum (10K shares). Returns False with error message if limits exceeded."
  },
  {
    "id": 240,
    "name": "check_symbol_tradeable",
    "type": "function",
    "current_summary": "Verify if a symbol is tradeable and registered in the system.",
    "snippet": "def check_symbol_tradeable(symbol: str, trace_id: str, order_id: str) -> tuple[bool, Optional[str]]:\n    \"\"\"\n    Verify if a symbol is tradeable and registered in the system.\n    \n    Args:\n        symbol: Stock ticker symbol\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        tuple: (is_tradeable, error_message)\n            - is_tradeable: True if symbol is tradeable, False otherwise\n            - error_message: None if tradeable, error description if not\n    \n    Checks:\n        - Symbol exists in registry\n        - Exchange information available\n        - Trading is enabled for the symbol\n    \"\"\"\n    logger.info(f\"[check_symbol_tradeable] Checking tradeability for {symbol}\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_symbol_tradeable'})\n    \n    metadata = get_symbol_metadata(symbol)\n    if not metadata:\n        logger.error(f\"[check_symbol_tradeable] Symbol {symbol} not found in registry\", \n                    extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_symbol_tradeable'})\n        return False, f\"Symbol '{symbol}' is not supported for trading\"\n    \n    # Check exchange status (simulated)\n    exchange = metadata['exchange']\n    logger.info(f\"[check_symbol_tradeable] Symbol {symbol} found on {exchange} exchange\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'check_symbol_tradeable', 'extra_data': metadata})\n    \n    return True, None",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Verifies if stock symbol is registered and tradeable in system. Checks symbol exists in registry and has exchange information. Returns False with error if symbol not supported (only AAPL, GOOGL, MSFT, AMZN, TSLA, META, NVDA allowed)."
  },
  {
    "id": 246,
    "name": "execute_trade",
    "type": "function",
    "current_summary": "Execute a validated trade",
    "snippet": "def execute_trade(trade: TradeExecutionRequest, request: Request):\n    \"\"\"\n    Execute a validated trade\n    \"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    # Create trace-specific log file\n    get_trace_logger(trace_id)\n    \n    logger.info(\"[execute_trade] Trade execution request received\", extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'execute_trade'})\n    logger.info(f\"[execute_trade] Executing - Symbol: {trade.symbol}, Quantity: {trade.quantity}, Price: ${trade.price}, Type: {trade.order_type}\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": trade.order_id,\n        \"function\": \"execute_trade\",\n        \"symbol\": trade.symbol,\n        \"quantity\": trade.quantity,\n        \"price\": trade.price\n    })\n    \n    execution_time = datetime.now().isoformat()\n    \n    # Store trade in database\n    logger.info(\"[execute_trade] Storing trade in database...\", extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'execute_trade'})\n    trades_db[trade.order_id] = {\n        \"order_id\": trade.order_id,\n        \"symbol\": trade.symbol,\n        \"quantity\": trade.quantity,\n        \"price\": trade.price,\n        \"order_type\": trade.order_type.value,\n        \"status\": \"EXECUTED\",\n        \"execution_time\": execution_time\n    }\n    \n    logger.info(\"[execute_trade] Trade executed successfully\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": trade.order_id,\n        \"function\": \"execute_trade\",\n        'extra_data': {\n            \"status\": \"EXECUTED\",\n            \"execution_time\": execution_time,\n            \"symbol\": trade.symbol,\n            \"quantity\": trade.quantity,\n            \"price\": trade.price,\n            \"total_value\": trade.quantity * trade.price\n        }\n    })\n    \n    return TradeExecutionResponse(\n        order_id=trade.order_id,\n        status=\"EXECUTED\",\n        execution_time=execution_time,\n        symbol=trade.symbol,\n        quantity=trade.quantity,\n        price=trade.price\n    )",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Executes approved trade by recording it in database. Stores order details, marks status as EXECUTED, records execution timestamp. Final step in trade workflow after validation, pricing, and risk approval."
  },
  {
    "id": 239,
    "name": "get_symbol_metadata",
    "type": "function",
    "current_summary": "Retrieve trading metadata for a stock symbol.",
    "snippet": "def get_symbol_metadata(symbol: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve trading metadata for a stock symbol.\n    \n    Args:\n        symbol: Stock ticker symbol\n    \n    Returns:\n        dict or None: Symbol metadata if found, None otherwise\n            Metadata includes:\n                - 'exchange': Trading exchange (e.g., 'NASDAQ')\n                - 'sector': Market sector\n                - 'lot_size': Minimum trading lot size\n                - 'max_order': Maximum order quantity allowed\n    \n    Example:\n        >>> get_symbol_metadata('AAPL')\n        {'exchange': 'NASDAQ', 'sector': 'Technology', 'lot_size': 1, 'max_order': 10000}\n    \"\"\"\n    symbol_registry = {\n        \"AAPL\": {\"exchange\": \"NASDAQ\", \"sector\": \"Technology\", \"lot_size\": 1, \"max_order\": 10000},\n        \"GOOGL\": {\"exchange\": \"NASDAQ\", \"sector\": \"Technology\", \"lot_size\": 1, \"max_order\": 5000},\n        \"MSFT\": {\"exchange\": \"NASDAQ\", \"sector\": \"Technology\", \"lot_size\": 1, \"max_order\": 10000},\n        \"AMZN\": {\"exchange\": \"NASDAQ\", \"sector\": \"Consumer\", \"lot_size\": 1, \"max_order\": 5000},\n        \"TSLA\": {\"exchange\": \"NASDAQ\", \"sector\": \"Automotive\", \"lot_size\": 1, \"max_order\": 3000},\n        \"META\": {\"exchange\": \"NASDAQ\", \"sector\": \"Technology\", \"lot_size\": 1, \"max_order\": 5000},\n        \"NVDA\": {\"exchange\": \"NASDAQ\", \"sector\": \"Technology\", \"lot_size\": 1, \"max_order\": 5000}\n    }\n    return symbol_registry.get(symbol)",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Retrieves trading metadata for stock symbols including exchange (NASDAQ), sector, lot size (minimum tradeable unit), and maximum order quantity. Returns None for unsupported symbols. Used for validation and normalization."
  },
  {
    "id": 247,
    "name": "get_trade",
    "type": "function",
    "current_summary": "Get trade details by order ID",
    "snippet": "def get_trade(order_id: str, request: Request):\n    \"\"\"Get trade details by order ID\"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    logger.info(\"[get_trade] Fetching trade details\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": order_id,\n        \"function\": \"get_trade\"\n    })\n    \n    trade = trades_db.get(order_id)\n    if not trade:\n        logger.warning(\"[get_trade] Trade not found\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": order_id,\n            \"function\": \"get_trade\"\n        })\n        raise HTTPException(status_code=404, detail=\"Trade not found\")\n    \n    return trade",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Retrieves completed trade details by order_id. Returns all trade information including execution time, status, symbol, quantity, and price. Raises 404 if trade not found."
  },
  {
    "id": 236,
    "name": "is_market_open",
    "type": "function",
    "current_summary": "Verify if trading market is currently open.",
    "snippet": "def is_market_open() -> bool:\n    \"\"\"\n    Verify if trading market is currently open.\n    \n    Returns:\n        bool: True if current time is within market hours, False otherwise\n    \n    Market Hours:\n        - Opens: 9:30 AM local time\n        - Closes: 11:00 PM local time (extended for demo purposes)\n    \n    Note:\n        Uses local system time. Production systems should use\n        exchange-specific timezone (typically US/Eastern)\n    \"\"\"\n    current_time = datetime.now().time()\n    market_open = time(9, 30)\n    market_close = time(23, 0)\n    \n    return market_open <= current_time <= market_close",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Checks if trading market is currently open. Market hours: 9:30 AM to 11:00 PM (extended for demo). Returns True during trading hours, False otherwise. Uses local system time."
  },
  {
    "id": 248,
    "name": "list_trades",
    "type": "function",
    "current_summary": "List all trades",
    "snippet": "def list_trades(request: Request):\n    \"\"\"List all trades\"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    logger.info(\"[list_trades] Listing all trades\", extra={\n        \"trace_id\": trace_id,\n        \"count\": len(trades_db),\n        \"function\": \"list_trades\"\n    })\n    \n    return {\"trades\": list(trades_db.values()), \"count\": len(trades_db)}",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Lists all executed trades with count. Used for portfolio tracking and trade history."
  },
  {
    "id": 242,
    "name": "normalize_quantity_to_lot_size",
    "type": "function",
    "current_summary": "Adjust order quantity to meet exchange lot size requirements.",
    "snippet": "def normalize_quantity_to_lot_size(quantity: int, symbol: str, trace_id: str, order_id: str) -> int:\n    \"\"\"\n    Adjust order quantity to meet exchange lot size requirements.\n    \n    Args:\n        quantity: Requested number of shares\n        symbol: Stock ticker symbol\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        int: Normalized quantity (rounded down to nearest lot size multiple)\n    \n    Example:\n        If lot_size = 10:\n        - Input: 157 â†’ Output: 150\n        - Input: 100 â†’ Output: 100 (no change)\n    \n    Note:\n        Rounds DOWN to nearest lot size. Fractional shares are not supported.\n        If symbol metadata unavailable, returns original quantity unchanged.\n    \"\"\"\n    logger.info(f\"[normalize_quantity_to_lot_size] Normalizing quantity {quantity} for {symbol}\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'normalize_quantity_to_lot_size'})\n    \n    metadata = get_symbol_metadata(symbol)\n    if not metadata:\n        logger.warning(f\"[normalize_quantity_to_lot_size] No metadata for {symbol}, using quantity as-is\", \n                      extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'normalize_quantity_to_lot_size'})\n        return quantity\n    \n    lot_size = metadata['lot_size']\n    if quantity % lot_size != 0:\n        normalized = (quantity // lot_size) * lot_size\n        logger.info(f\"[normalize_quantity_to_lot_size] Adjusted quantity from {quantity} to {normalized} (lot size: {lot_size})\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'normalize_quantity_to_lot_size', \n                          'extra_data': {'original': quantity, 'normalized': normalized, 'lot_size': lot_size}})\n        return normalized\n    \n    return quantity",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Adjusts order quantity to meet exchange lot size requirements. Rounds DOWN to nearest lot size multiple (e.g., 157 shares with lot size 10 becomes 150). Ensures compliance with exchange trading rules."
  },
  {
    "id": 237,
    "name": "validate_account_balance",
    "type": "function",
    "current_summary": "Verify sufficient funds (BUY) or holdings (SELL) for order execution.",
    "snippet": "def validate_account_balance(quantity: int, price: float, symbol: str, order_type: OrderType, trace_id: str, order_id: str) -> tuple[bool, Optional[str]]:\n    \"\"\"\n    Verify sufficient funds (BUY) or holdings (SELL) for order execution.\n    \n    Args:\n        quantity: Number of shares to trade\n        price: Estimated price per share\n        symbol: Stock ticker symbol\n        order_type: BUY or SELL\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        tuple: (is_valid, error_message)\n            - is_valid: True if sufficient balance/holdings, False otherwise\n            - error_message: None if valid, error description if not\n    \n    Validation Logic:\n        BUY: Checks if (quantity Ã— price) â‰¤ account balance ($500K)\n        SELL: Checks if quantity â‰¤ current holdings for the symbol\n    \n    Note:\n        Uses estimated price for validation. Actual price may differ at execution\n    \"\"\"\n    logger.info(f\"[validate_account_balance] Validating account for {order_type} order\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_account_balance'})\n    \n    if order_type == OrderType.BUY:\n        # Check buying power for purchase\n        account_balance = 500000  # $500K available\n        required_amount = quantity * price\n        \n        logger.info(f\"[validate_account_balance] BUY - Required: ${required_amount:.2f}, Available: ${account_balance:.2f}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_account_balance',\n                          'extra_data': {'required': required_amount, 'available': account_balance}})\n        \n        if required_amount > account_balance:\n            logger.error(f\"[validate_account_balance] Insufficient buying power: need ${required_amount:.2f}, have ${account_balance:.2f}\", \n                        extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_account_balance'})\n            return False, f\"Insufficient buying power: ${required_amount:.2f} required, ${account_balance:.2f} available\"\n    else:\n        # Check holdings for sale\n        holdings = {\"AAPL\": 500, \"GOOGL\": 200, \"MSFT\": 800, \"TSLA\": 300, \"NVDA\": 300}\n        current_holdings = holdings.get(symbol, 0)\n        \n        logger.info(f\"[validate_account_balance] SELL - Current holdings: {current_holdings} shares of {symbol}\", \n                   extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_account_balance',\n                          'extra_data': {'symbol': symbol, 'holdings': current_holdings, 'sell_quantity': quantity}})\n        \n        if current_holdings < quantity:\n            logger.error(f\"[validate_account_balance] Insufficient shares: have {current_holdings}, trying to sell {quantity}\", \n                        extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_account_balance'})\n            return False, f\"Insufficient shares: have {current_holdings} shares, cannot sell {quantity}\"\n    \n    logger.info(\"[validate_account_balance] Account validation passed\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_account_balance'})\n    return True, None",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Verifies sufficient account balance/holdings for order. For BUY: checks if order cost â‰¤ account balance ($500K). For SELL: checks if quantity â‰¤ current holdings. Returns False with specific error if insufficient funds/shares."
  },
  {
    "id": 238,
    "name": "validate_order_requirements",
    "type": "function",
    "current_summary": "Validate all order-type specific requirements.",
    "snippet": "def validate_order_requirements(symbol: str, quantity: int, price: float, order_type: OrderType, trace_id: str, order_id: str) -> tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate all order-type specific requirements.\n    \n    Args:\n        symbol: Stock ticker symbol\n        quantity: Number of shares\n        price: Estimated price per share\n        order_type: BUY or SELL\n        trace_id: Trace ID for logging\n        order_id: Order ID for logging\n    \n    Returns:\n        tuple: (is_valid, error_message)\n            - is_valid: True if all requirements met, False otherwise\n            - error_message: None if valid, error description if not\n    \n    Validations Performed:\n        - Account balance/holdings verification\n        - Order-type specific business rules\n    \"\"\"\n    logger.info(f\"[validate_order_requirements] Validating {order_type} order requirements\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_order_requirements'})\n    \n    # Validate account balance/holdings\n    is_valid, msg = validate_account_balance(quantity, price, symbol, order_type, trace_id, order_id)\n    if not is_valid:\n        return False, msg\n    \n    logger.info(f\"[validate_order_requirements] {order_type} order validation passed\", \n               extra={'trace_id': trace_id, 'order_id': order_id, 'function': 'validate_order_requirements'})\n    return True, None",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Validates all order-type specific requirements by calling account balance/holdings validation. Wrapper function that ensures proper validation based on whether order is BUY or SELL."
  },
  {
    "id": 244,
    "name": "validate_quantity",
    "type": "function",
    "current_summary": "Perform basic quantity validation and normalization.",
    "snippet": "def validate_quantity(quantity: int) -> int:\n    \"\"\"\n    Perform basic quantity validation and normalization.\n    \n    Args:\n        quantity: Requested order quantity\n    \n    Returns:\n        int: Validated quantity, or error codes:\n            - Returns quantity if valid (0 < quantity â‰¤ 10,000)\n            - Returns 0 if quantity < 0\n            - Returns -1 if quantity > 10,000 (exceeds maximum)\n    \n    Note:\n        This is a simple validation. Use check_order_limits() for\n        comprehensive limit checking with proper error messages.\n    \"\"\"\n    if quantity < 0:\n        return 0\n    \n    # Check maximum limit\n    if quantity > 10000:\n        return -1  # Invalid\n    \n    return quantity",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Basic quantity validation helper. Returns 0 if quantity negative, -1 if exceeds 10K maximum, otherwise returns quantity unchanged. Simplified check used before comprehensive validation."
  },
  {
    "id": 241,
    "name": "validate_symbol",
    "type": "function",
    "current_summary": "Check if symbol is in the list of supported trading symbols.",
    "snippet": "def validate_symbol(symbol: str) -> bool:\n    \"\"\"\n    Check if symbol is in the list of supported trading symbols.\n    \n    Args:\n        symbol: Stock ticker symbol\n    \n    Returns:\n        bool: True if symbol is supported, False otherwise\n    \n    Supported Symbols:\n        AAPL, GOOGL, MSFT, AMZN, TSLA, META, NVDA\n    \"\"\"\n    supported_symbols = [\"AAPL\", \"GOOGL\", \"MSFT\", \"AMZN\", \"TSLA\", \"META\", \"NVDA\"]\n    return symbol in supported_symbols",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Simple check if symbol is in supported list (AAPL, GOOGL, MSFT, AMZN, TSLA, META, NVDA). Returns True if supported, False otherwise. Used for quick symbol validation."
  },
  {
    "id": 245,
    "name": "validate_trade",
    "type": "function",
    "current_summary": "Validate a trade before execution",
    "snippet": "def validate_trade(trade: TradeValidationRequest, request: Request):\n    \"\"\"\n    Validate a trade before execution\n    Checks: market hours, symbol validity, quantity constraints\n    \"\"\"\n    trace_id = get_trace_id(request.headers.get(\"X-Trace-Id\"))\n    \n    # Create trace-specific log file\n    get_trace_logger(trace_id)\n    \n    logger.info(\"[validate_trade] Trade validation request received\", extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade'})\n    logger.info(f\"[validate_trade] Validating - Symbol: {trade.symbol}, Quantity: {trade.quantity}, Type: {trade.order_type}\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": trade.order_id,\n        \"function\": \"validate_trade\",\n        \"symbol\": trade.symbol,\n        \"quantity\": trade.quantity,\n        \"order_type\": trade.order_type\n    })\n    \n    timestamp = datetime.now().isoformat()\n    \n    # Step 1: Check if symbol is tradeable\n    logger.info(\"[validate_trade] Step 1: Checking symbol tradeability\", \n               extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade'})\n    is_tradeable, reason = check_symbol_tradeable(trade.symbol, trace_id, trade.order_id)\n    if not is_tradeable:\n        logger.warning(f\"[validate_trade] Symbol validation failed: {reason}\", \n                      extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade'})\n        return TradeValidationResponse(\n            valid=False,\n            reason=reason,\n            order_id=trade.order_id,\n            normalized_quantity=trade.quantity,\n            timestamp=timestamp\n        )\n    \n    # Step 2: Check market hours\n    logger.info(\"[validate_trade] Step 2: Checking market hours\", \n               extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade'})\n    logger.info(\"[validate_trade] is_market_open checking...\", extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'is_market_open'})\n    market_open = is_market_open()\n    logger.info(f\"[is_market_open] Market status: {'OPEN' if market_open else 'CLOSED'}\", extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'is_market_open', 'extra_data': {'market_open': market_open}})\n    \n    if not market_open:\n        logger.warning(\"[validate_trade] VALIDATION FAILED - Market is currently closed\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": trade.order_id,\n            \"function\": \"validate_trade\",\n            'extra_data': {'reason': 'market_closed', 'trading_hours': '9:00 AM - 4:00 PM'}\n        })\n        return TradeValidationResponse(\n            valid=False,\n            reason=\"Market is currently closed. Trading hours: 9:00 AM - 4:00 PM\",\n            order_id=trade.order_id,\n            normalized_quantity=trade.quantity,\n            timestamp=timestamp\n        )\n    \n    # Step 3: Validate order type specific requirements\n    logger.info(\"[validate_trade] Step 3: Validating order type specific requirements\", \n               extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade'})\n    \n    # Basic quantity validation\n    if trade.quantity <= 0:\n        logger.error(f\"[validate_trade] Invalid quantity: {trade.quantity}\", \n                    extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade'})\n        return TradeValidationResponse(\n            valid=False,\n            reason=f\"Quantity must be positive (received: {trade.quantity})\",\n            order_id=trade.order_id,\n            normalized_quantity=trade.quantity,\n            timestamp=timestamp\n        )\n    \n    # Use estimated price for quick validation check\n    # Full pricing calculation happens in pricing service during execution\n    estimated_price = 175.0  # Standard reference price for validation\n    \n    logger.info(f\"[validate_trade] Using estimated price ${estimated_price} for validation\", \n               extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade',\n                      'extra_data': {'estimated_price': estimated_price, 'symbol': trade.symbol}})\n    \n    # Call generic validation function\n    order_valid, validation_msg = validate_order_requirements(trade.symbol, trade.quantity, estimated_price, trade.order_type, trace_id, trade.order_id)\n    \n    if not order_valid:\n        logger.warning(f\"[validate_trade] Order validation failed: {validation_msg}\", \n                      extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade'})\n        return TradeValidationResponse(\n            valid=False,\n            reason=validation_msg,\n            order_id=trade.order_id,\n            normalized_quantity=trade.quantity,\n            timestamp=timestamp\n        )\n    \n    # Normalize to lot size\n    normalized_qty = normalize_quantity_to_lot_size(trade.quantity, trade.symbol, trace_id, trade.order_id)\n    \n    # Check order limits\n    limits_ok, limit_reason = check_order_limits(normalized_qty, trade.symbol, trace_id, trade.order_id)\n    if not limits_ok:\n        logger.warning(f\"[validate_trade] VALIDATION FAILED - {limit_reason}\", extra={\n            \"trace_id\": trace_id,\n            \"order_id\": trade.order_id,\n            \"function\": \"validate_trade\",\n            \"quantity\": trade.quantity\n        })\n        return TradeValidationResponse(\n            valid=False,\n            reason=limit_reason,\n            order_id=trade.order_id,\n            normalized_quantity=normalized_qty,\n            timestamp=timestamp\n        )\n    \n    # Update trade with normalized quantity\n    trade.quantity = normalized_qty\n    logger.info(f\"[validate_trade] Quantity validation passed: {normalized_qty}\", \n               extra={'trace_id': trace_id, 'order_id': trade.order_id, 'function': 'validate_trade'})\n    \n    logger.info(\"[validate_trade] Trade validation successful\", extra={\n        \"trace_id\": trace_id,\n        \"order_id\": trade.order_id,\n        \"function\": \"validate_trade\",\n        'extra_data': {'symbol': trade.symbol, 'quantity': trade.quantity, 'order_type': trade.order_type.value}\n    })\n    \n    return TradeValidationResponse(\n        valid=True,\n        reason=None,\n        order_id=trade.order_id,\n        normalized_quantity=normalized_qty,\n        timestamp=timestamp\n    )",
    "filePath": "..\\trade-platform\\trade_service\\src\\app.py",
    "serviceName": "trade_service",
    "new_summary": "Main trade validation endpoint. Performs comprehensive 3-step validation: (1) checks symbol tradeability, (2) verifies market is open, (3) validates order requirements (balance/holdings). Normalizes quantity to lot size and checks order limits. Returns validation response with normalized quantity or rejection reason. First critical step in trade workflow."
  }
]
